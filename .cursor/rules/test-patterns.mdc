---
alwaysApply: true
---
# Test Patterns and Rules for money-warp

This document defines the testing patterns and rules for the **money-warp** project to ensure consistent, maintainable, and effective test suites.

## Core Testing Principles

### 1. No Class-Based Test Cases ‚≠ê
**NEVER use class-based test cases. Use function-based tests only.**

- **Avoid**: `class TestMoney:` or `class TestSomething:`
- **Use**: Individual test functions with descriptive names
- **Reason**: Tests are deterministic and don't need object-oriented structure

### 2. Single Assert Per Test ‚≠ê
**Each test function should have exactly ONE assert statement.**

- **Good**: `def test_money_addition_basic(): assert money1 + money2 == expected`
- **Bad**: Multiple asserts testing different aspects in one function
- **Reason**: Clear failure identification and focused test purpose

### 3. Parametrized Tests for Multiple Cases ‚≠ê
**Use pytest.mark.parametrize for testing multiple input/output combinations.**

```python
@pytest.mark.parametrize("amount,expected", [
    ("100.50", Decimal("100.50")),
    (100, Decimal("100.00")),
    (Decimal("100.50"), Decimal("100.50")),
])
def test_money_creation_from_various_types(amount, expected):
    money = Money(amount)
    assert money.real_amount == expected
```

### 4. Descriptive Test Names
**Test function names should clearly describe what is being tested.**

- **Pattern**: `test_[component]_[action]_[scenario]`
- **Good**: `test_money_addition_with_high_precision`
- **Good**: `test_money_comparison_equal_amounts`
- **Bad**: `test_money_1`, `test_addition`

### 5. No Conditional Logic in Tests
**Tests should be deterministic - avoid if statements, loops, or conditional logic.**

- **Bad**: `if condition: assert something`
- **Good**: Separate tests for different conditions
- **Use**: Parametrized tests for multiple scenarios

### 6. Test Organization Patterns

#### File Structure
```
tests/
‚îú‚îÄ‚îÄ test_money.py          # Money class tests
‚îú‚îÄ‚îÄ test_interest_rate.py  # InterestRate class tests
‚îú‚îÄ‚îÄ test_cash_flow.py      # CashFlow class tests
‚îî‚îÄ‚îÄ test_loan.py           # Loan class tests
```

#### Function Grouping
Group related tests with consistent prefixes:
```python
# Creation tests
def test_money_creation_from_string():
def test_money_creation_from_int():
def test_money_creation_zero():

# Arithmetic tests  
def test_money_addition_basic():
def test_money_subtraction_basic():
def test_money_multiplication_by_integer():

# Comparison tests
def test_money_equality_same_amounts():
def test_money_less_than_comparison():
```

## Testing Patterns

### 1. Basic Property Testing
```python
def test_money_real_amount_property():
    money = Money("100.50")
    assert money.real_amount == Decimal("100.50")
```

### 2. Parametrized Input Testing
```python
@pytest.mark.parametrize("input_value,expected_output", [
    ("100.50", "100.50"),
    (100, "100.00"),
    ("0", "0.00"),
])
def test_money_string_representation(input_value, expected_output):
    money = Money(input_value)
    assert str(money) == expected_output
```

### 3. Error Condition Testing
```python
def test_money_division_by_zero_raises_error():
    money = Money("100.00")
    with pytest.raises(ZeroDivisionError):
        money / 0
```

### 4. Precision Testing
```python
def test_money_high_precision_internal_storage():
    money = Money("100.123456789")
    assert money.raw_amount == Decimal("100.123456789")

def test_money_real_amount_rounds_to_two_decimals():
    money = Money("100.123456789")
    assert money.real_amount == Decimal("100.12")
```

### 5. Edge Case Testing
```python
def test_money_very_large_amount():
    money = Money("999999999.99")
    assert money.real_amount == Decimal("999999999.99")

def test_money_very_small_amount_rounds_to_zero():
    money = Money("0.001")
    assert money.real_amount == Decimal("0.00")
```

## Test Quality Guidelines

### 1. Test Independence
- Each test should be completely independent
- No shared state between tests
- Use fresh objects in each test

### 2. Clear Assertions
```python
# Good - clear expectation
def test_money_addition_result():
    money1 = Money("100.50")
    money2 = Money("50.25")
    result = money1 + money2
    assert result.real_amount == Decimal("150.75")

# Bad - unclear what's being tested
def test_money_operations():
    money = Money("100")
    assert money.real_amount > 0
```

### 3. Meaningful Test Data
- Use realistic values that represent actual use cases
- Include edge cases (zero, negative, very large/small)
- Use values that make the test intent clear

### 4. Comprehensive Coverage
- Test all public methods and properties
- Test error conditions and edge cases
- Test interactions between components
- Aim for >90% code coverage

## Fixtures and Utilities

### 1. Simple Fixtures for Common Objects
```python
@pytest.fixture
def sample_money():
    return Money("100.50")

@pytest.fixture  
def zero_money():
    return Money.zero()
```

### 2. Parametrized Fixtures for Multiple Scenarios
```python
@pytest.fixture(params=[
    Money("100.00"),
    Money("50.25"), 
    Money("0.01"),
])
def various_money_amounts(request):
    return request.param
```

## Anti-Patterns to Avoid

### 1. ‚ùå Class-Based Tests
```python
# DON'T DO THIS
class TestMoney:
    def test_addition(self):
        pass
```

### 2. ‚ùå Multiple Asserts
```python
# DON'T DO THIS
def test_money_properties():
    money = Money("100.50")
    assert money.real_amount == Decimal("100.50")  # Multiple asserts
    assert money.cents == 10050
    assert money.is_positive()
```

### 3. ‚ùå Conditional Logic
```python
# DON'T DO THIS
def test_money_comparison():
    money1 = Money("100")
    money2 = Money("50")
    if money1 > money2:
        assert True
    else:
        assert False
```

### 4. ‚ùå Vague Test Names
```python
# DON'T DO THIS
def test_money_1():
def test_addition():
def test_works():
```

## Example: Complete Test File Structure

```python
"""Tests for Money class - following project patterns."""

import pytest
from decimal import Decimal
from money_warp.money import Money


# Creation tests
@pytest.mark.parametrize("amount,expected", [
    ("100.50", Decimal("100.50")),
    (100, Decimal("100.00")),
    (Decimal("100.50"), Decimal("100.50")),
])
def test_money_creation_from_various_types(amount, expected):
    money = Money(amount)
    assert money.real_amount == expected


def test_money_creation_zero_class_method():
    money = Money.zero()
    assert money.is_zero()


# Arithmetic tests
def test_money_addition_basic_amounts():
    money1 = Money("100.50")
    money2 = Money("50.25")
    result = money1 + money2
    assert result.real_amount == Decimal("150.75")


def test_money_division_maintains_high_precision():
    money = Money("100.00")
    result = money / 3
    assert result.raw_amount == Decimal("100.00") / 3


# Comparison tests
def test_money_equality_same_amounts():
    money1 = Money("100.50")
    money2 = Money("100.50")
    assert money1 == money2


# Property tests
def test_money_cents_property_conversion():
    money = Money("123.45")
    assert money.cents == 12345


# Edge case tests
def test_money_very_small_amount_rounds_down():
    money = Money("0.001")
    assert money.real_amount == Decimal("0.00")
```

---

**Remember**: Keep tests simple, focused, and deterministic. One test, one assert, one purpose! üß™