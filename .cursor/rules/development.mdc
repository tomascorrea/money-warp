---
alwaysApply: true
---
# Development Rules for money-warp

This document contains development guidelines and rules for working on the **money-warp** project. These rules are designed to ensure consistent, high-quality code and effective collaboration.

## Core Development Principles

### 1. Plan Before Coding â­
**ALWAYS plan before writing any code.**

- **Think first, code second**: Before touching any code, take time to understand the problem and design the solution
- **Create a clear plan**: Write down what you're going to do, how you're going to do it, and what the expected outcome is
- **Consider edge cases**: Think through potential issues and how to handle them
- **Review existing code**: Understand how your changes fit into the existing codebase
- **Break down complex tasks**: Split large features into smaller, manageable pieces

### 2. Two Audiences for Documentation â­
**`docs/` and `README.md` are for humans. `knowledge/` is for the AI.**

- **`docs/` and `README.md`**: Written for human readers â€” developers, users, contributors. Focus on clarity, examples, and getting-started guidance. Keep the tone approachable.
- **`knowledge/`**: Written for AI context â€” the agent reads these files to understand the current state of the codebase. Focus on precision, design decisions, API surface, gotchas, and non-obvious learnings. Conciseness matters more than prose quality.
- **Both must stay in sync**: When a feature changes, update both the human-facing docs and the AI-facing knowledge files. They describe the same system from different angles.

### 3. Knowledge Directory (AI Context) â­
**Maintain `knowledge/` as living documentation of features, architecture, and hard-won learnings.**

The `knowledge/` directory contains one file per feature area. Each file describes the **current state** of that area â€” its design, API surface, key decisions, and gotchas.

- **Organization**: One markdown file per feature area (e.g., `loan.md`, `warp.md`, `tvm.md`)
- **Format**: Each file follows a consistent structure: Overview, Design Decisions, API Surface, Key Learnings/Gotchas
- **Living documents**: Rewrite sections to reflect the current state â€” these are not append-only changelogs

**When to update:**
- After completing a new feature â€” create or extend the relevant file
- After fixing a significant bug that revealed something non-obvious â€” add to Key Learnings
- After making an architectural change â€” update the affected files

**What does NOT belong here:**
- Task lists, progress tracking, or backlog items (use Cursor's built-in planning)
- Changelogs or timestamps (knowledge files describe the present, not the history)
- Documentation for end users (that lives in `docs/`)

### 4. Use Money for Money â­
**ALWAYS use the `Money` type when representing monetary amounts.**

- **Function parameters and return types**: If a value represents money, it must be `Money` â€” never a raw `Decimal`, `float`, or `int`.
- **Internal calculations**: Use `Money.raw_amount` only when raw `Decimal` arithmetic is unavoidable inside a method. Wrap the result back into `Money` before returning.
- **Rationale**: `Money` carries precision semantics (`raw_amount` vs `real_amount`), supports safe arithmetic, and makes interfaces self-documenting. Passing bare `Decimal` values forces every caller to know whether the value is rounded or not.

### 5. Use scipy for Numerical Solving â­
**ALWAYS use `scipy.optimize` (fsolve, brentq, etc.) for root-finding and numerical convergence problems. NEVER write hand-rolled iterative loops for these.**

- **Root-finding**: Use `scipy.optimize.fsolve` or `scipy.optimize.brentq` instead of manual fixed-point iteration or bisection loops.
- **Rationale**: scipy solvers are battle-tested, handle edge cases (convergence failure, ill-conditioned problems), and are more robust than hand-written loops. They also communicate intent more clearly â€” a call to `fsolve` signals "find the root" immediately.
- **Pattern**: Define an objective function `f(x) = 0`, pass it to the solver with an initial guess, and check the convergence flag.

## Project Structure Guidelines

### Directory Structure
```
money-warp/
â”œâ”€â”€ knowledge/         # Living feature documentation (see Core Principles Â§2)
â”‚   â”œâ”€â”€ architecture.md   # Overall design, component relationships
â”‚   â”œâ”€â”€ loan.md           # Loan model, schedulers, fines, mora interest
â”‚   â”œâ”€â”€ warp.md           # Time Machine context manager
â”‚   â”œâ”€â”€ tvm.md            # Present value, IRR, MIRR
â”‚   â””â”€â”€ environment.md    # Dev environment setup
â”œâ”€â”€ money_warp/        # Main package code
â”œâ”€â”€ tests/             # Test files
â”œâ”€â”€ docs/              # Documentation
â””â”€â”€ pyproject.toml     # Poetry configuration
```

### Code Organization
- **Main package**: All source code goes in `money_warp/`
- **Tests**: Mirror the package structure in `tests/`
- **Documentation**: Use `docs/` for project documentation
- **Configuration**: Keep configuration in `pyproject.toml`

## Poetry Workflow Guidelines

### Dependency Management â­
**ALWAYS use Poetry for dependency management. NEVER use `pip` directly.**

```bash
# âœ… CORRECT
poetry add package_name
poetry add --group dev package_name

# âŒ WRONG â€” never do this
pip install package_name
```

- **Add dependencies**: `poetry add package_name`
- **Add dev dependencies**: `poetry add --group dev package_name`
- **Lock dependencies**: Always commit `poetry.lock`
- **Install project**: `poetry install` (includes dev dependencies)
- **Production install**: `poetry install --only main`

### Virtual Environment
- **Activate shell**: `poetry shell`
- **Run commands**: `poetry run command`
- **Check environment**: `poetry env info`

### Version Management
- **Update version**: `poetry version patch|minor|major`
- **Build package**: `poetry build`
- **Publish**: `poetry publish`

## Code Style and Formatting

### Formatting Tools
- **Black**: Code formatting (`poetry run black .`)
- **isort**: Import sorting (`poetry run isort .`)
- **Ruff**: Linting and more (`poetry run ruff check .`)

### Pre-commit Hooks
- Install: `poetry run pre-commit install`
- Run manually: `poetry run pre-commit run --all-files`
- All checks must pass before committing

### Code Quality Standards
- **Type hints**: Use type hints for all functions and classes
- **Docstrings**: Follow Google or NumPy docstring style
- **Line length**: 88 characters (Black default)
- **Imports**: Group and sort with isort
- **Naming**: Use snake_case for functions/variables, PascalCase for classes

## Testing Guidelines

### Test Structure
- **Mirror package structure**: `tests/` should mirror `money_warp/`
- **Test file naming**: `test_module_name.py`
- **Test function naming**: `test_function_name_scenario()`

### Testing Tools
- **pytest**: Primary testing framework
- **coverage**: Code coverage measurement
- **pytest-cov**: Coverage integration for pytest

### Test Commands
- **Run tests**: `poetry run pytest`
- **With coverage**: `poetry run pytest --cov=money_warp`
- **Coverage report**: `poetry run coverage html`

### Test Quality
- **Test coverage**: Aim for >90% coverage
- **Test types**: Unit tests, integration tests, end-to-end tests
- **Mock external dependencies**: Use `unittest.mock` or `pytest-mock`
- **Test data**: Use fixtures for reusable test data

## Git Workflow

### Branch Strategy
- **Main branch**: `main` (production-ready code)
- **Feature branches**: `feature/description` or `feat/description`
- **Bug fixes**: `fix/description` or `bugfix/description`
- **Hotfixes**: `hotfix/description`

### Commit Guidelines
- **Conventional commits**: Use conventional commit format
- **Commit messages**: Clear, descriptive messages
- **Atomic commits**: One logical change per commit
- **Commit frequently**: Small, frequent commits are better

### Pull Request Process
1. Create feature branch from `main`
2. Make changes following these guidelines
3. Run all tests and checks locally
4. Create pull request with clear description
5. Wait for CI/CD to pass
6. Request code review
7. Address feedback
8. Merge when approved

## Documentation Standards

### Code Documentation
- **Docstrings**: All public functions, classes, and modules
- **Type hints**: Comprehensive type annotations
- **Comments**: Explain complex logic, not obvious code
- **README**: Keep project README up to date

### Project Documentation
- **API docs**: Auto-generated from docstrings
- **User guides**: How to use the project
- **Developer guides**: How to contribute
- **Changelog**: Document all changes

## Development Environment

### Required Tools
- **Python**: Version specified in `pyproject.toml`
- **Poetry**: Latest stable version
- **Git**: Version control
- **Pre-commit**: Git hooks for quality checks

### IDE Configuration
- **Editor config**: Follow `.editorconfig` settings
- **Linting**: Enable real-time linting
- **Formatting**: Auto-format on save
- **Type checking**: Enable mypy integration

### Environment Setup
1. Clone repository
2. Install Poetry
3. Run `poetry install`
4. Run `poetry run pre-commit install`
5. Create feature branch
6. Start developing!

## Common Commands

### Development Workflow
```bash
# Setup
poetry install
poetry run pre-commit install

# Before starting work
git checkout main
git pull origin main
git checkout -b feature/my-feature

# During development
poetry run pytest                    # Run tests
poetry run black .                   # Format code
poetry run ruff check .             # Lint code

# Before committing
poetry run pre-commit run --all-files  # Run all checks
git add .
git commit -m "feat: add new feature"
git push origin feature/my-feature
```

### Quality Checks
```bash
# Full quality check suite
poetry run pytest --cov=money_warp
poetry run black --check .
poetry run isort --check .
poetry run ruff check .
```

## Troubleshooting

### Common Issues
- **Poetry lock conflicts**: `poetry lock --no-update`
- **Pre-commit issues**: `poetry run pre-commit clean`
- **Import errors**: Check `PYTHONPATH` and virtual environment
- **Test failures**: Ensure dependencies are installed

### Getting Help
1. Check this document first
2. Review project documentation
3. Search existing issues
4. Ask team members
5. Create new issue with detailed description

---

**Remember**: When in doubt, plan first, code second! ðŸš€
