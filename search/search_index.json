{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MoneyWarp \ud83d\udcb0\u23f0","text":"<p>Bend time. Model cash.</p> <p> </p> <p>\u26a0\ufe0f Development Stage Notice</p> <p>MoneyWarp is currently in active development and should be considered alpha/pre-release software. While the core functionality is implemented and tested, the API may change between versions. Use in production environments at your own risk.</p> <ul> <li>\u2705 Core classes (<code>Money</code>, <code>InterestRate</code>, <code>CashFlow</code>, <code>Loan</code>) are stable</li> <li>\u2705 Comprehensive test suite with 830+ tests</li> <li>\u2705 Time Machine, Present Value, and IRR functions complete</li> <li>\u26a0\ufe0f API may evolve based on user feedback</li> <li>\u26a0\ufe0f Not yet published to PyPI</li> <li>\ud83d\udea7 Additional features and schedulers in development</li> </ul> <p>MoneyWarp is a Python library for working with the time value of money. It treats loans, annuities, and investments as simple cash flows through time \u2014 and gives you the tools to warp them back and forth between present, future, and everything in between.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>\ud83d\udd70\ufe0f Time Machine (Warp) - Travel to any date and see loan state as of that moment</li> <li>\ud83d\udd22 Calculate PMT, NPV, IRR, MIRR and other core finance functions with scipy</li> <li>\u23f3 Track loans and repayments as evolving cash-flow streams  </li> <li>\ud83c\udf00 Explore \"what if\" timelines by bending payments across time</li> <li>\ud83d\udcb0 High-precision calculations using Decimal arithmetic</li> <li>\ud83d\udcca Progressive Price Schedules (French amortization system)</li> <li>\ud83d\udcc8 Inverted Price Schedules (Constant Amortization System - SAC)</li> <li>\ud83c\udfaf Flexible payment scheduling with irregular due dates</li> <li>\ud83d\udcc5 Easy date generation with smart month-end handling via python-dateutil</li> <li>\ud83d\udd12 Type-safe interest rates with explicit percentage handling</li> <li>\ud83e\uddee Robust numerics powered by scipy for IRR and financial calculations</li> <li>\u2696\ufe0f Fine engine with fines, mora interest, and configurable grace periods</li> <li>\ud83c\udf6d Sugar payment methods \u2014 <code>pay_installment()</code> and <code>anticipate_payment()</code></li> <li>\ud83d\udccb Installments &amp; Settlements \u2014 first-class views of the repayment plan and payment allocation</li> <li>\ud83c\udde7\ud83c\uddf7 Tax module \u2014 Brazilian IOF with pluggable tax strategy, grossup, and preset rates</li> <li>\ud83c\udf10 Timezone-aware \u2014 all datetimes are UTC by default, configurable globally</li> </ul>"},{"location":"#time-value-of-money-functions","title":"\ud83e\uddee Time Value of Money Functions","text":"<p>MoneyWarp provides comprehensive TVM functions powered by scipy:</p>"},{"location":"#present-value-functions","title":"Present Value Functions","text":"<ul> <li>Present Value (PV): Discount future cash flows to present value</li> <li>Net Present Value (NPV): Sum of discounted cash flows</li> <li>Present Value of Annuities: Regular payment streams</li> <li>Present Value of Perpetuities: Infinite payment streams</li> <li>Discount Factors: Time value calculations</li> </ul>"},{"location":"#internal-rate-of-return","title":"Internal Rate of Return","text":"<ul> <li>IRR: Rate where NPV equals zero (scipy-powered for reliability)</li> <li>Modified IRR (MIRR): IRR with different financing/reinvestment rates</li> <li>Day-count conventions: <code>YearSize.commercial</code> (365) or <code>YearSize.banker</code> (360) for IRR and MIRR</li> <li>Automatic bracketing: Robust root finding across complex cash flows</li> <li>Sugar syntax: <code>loan.irr()</code> convenience methods (automatically uses the loan's <code>year_size</code>)</li> </ul>"},{"location":"#integration-features","title":"Integration Features","text":"<ul> <li>Time Machine compatibility: All functions work with <code>Warp</code></li> <li>High precision: Maintains decimal precision throughout</li> <li>Type safety: Full type annotations and mypy compatibility</li> <li>Error handling: Clear messages and edge case handling</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcd6 Documentation","text":"<p>Explore the comprehensive examples and API reference:</p> <ul> <li>Quick Start - Get up and running quickly</li> <li>Money - High-precision monetary amounts</li> <li>Interest Rates - Type-safe rate handling and conversions</li> <li>Date Generation - Smart payment date utilities</li> <li>Present Value &amp; IRR - TVM functions and analysis</li> <li>Time Machine - Travel through time with loans</li> <li>Cash Flow Analysis - Work with cash flow streams</li> <li>Fines &amp; Payments - Fines, mora interest, installments, settlements, and payment methods</li> <li>Tax &amp; IOF - Brazilian IOF, grossup, and pluggable taxes</li> <li>Timezone Handling - UTC default, global configuration, silent coercion</li> <li>API Reference - Complete function documentation</li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>MoneyWarp is built around core financial concepts:</p> <ul> <li>\ud83d\udcb0 Money: High-precision monetary amounts using Decimal</li> <li>\ud83d\udcc8 InterestRate: Type-safe rates with frequency conversions, abbreviated notation, and day-count conventions</li> <li>\ud83d\udcb8 CashFlow: Collections with SQLAlchemy-style querying</li> <li>\ud83c\udfe6 Loan: State machines for loan analysis and tracking</li> <li>\ud83d\udccb Installment &amp; Settlement: Derived views of repayment plans and payment allocations</li> <li>\ud83c\udde7\ud83c\uddf7 Tax: Pluggable tax strategy with IOF, grossup, and presets</li> <li>\ud83c\udf10 tz: Timezone configuration \u2014 UTC default, global <code>set_tz()</code>, silent coercion</li> <li>\ud83d\udd70\ufe0f Warp: Time Machine for temporal financial analysis</li> </ul>"},{"location":"#quality-testing","title":"\ud83e\uddea Quality &amp; Testing","text":"<ul> <li>830+ comprehensive tests with 100% core functionality coverage</li> <li>Type safety: Full mypy compatibility with zero type errors</li> <li>Code quality: Passes ruff linting and black formatting</li> <li>Robust numerics: Scipy-powered calculations for reliability</li> <li>Reference validation: Tested against established financial libraries</li> </ul> <p>MoneyWarp combines the power of modern Python with solid financial theory to provide a reliable foundation for time value of money calculations.</p>"},{"location":"modules/","title":"API Reference","text":"<p>MoneyWarp provides a comprehensive set of classes for financial calculations and time-based analysis.</p>"},{"location":"modules/#core-classes","title":"Core Classes","text":""},{"location":"modules/#money","title":"Money","text":""},{"location":"modules/#money_warp.Money","title":"<code>money_warp.Money</code>","text":"<p>Represents a monetary amount with high internal precision.</p> <p>Maintains full precision internally for calculations but provides 'real money' representation rounded to 2 decimal places for display and comparisons.</p>"},{"location":"modules/#money_warp.Money-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.Money.raw_amount","title":"<code>raw_amount</code>  <code>property</code>","text":"<p>Get the high-precision internal amount.</p>"},{"location":"modules/#money_warp.Money.real_amount","title":"<code>real_amount</code>  <code>property</code>","text":"<p>Get the 'real money' amount rounded to 2 decimal places.</p>"},{"location":"modules/#money_warp.Money.cents","title":"<code>cents</code>  <code>property</code>","text":"<p>Get real amount in cents.</p>"},{"location":"modules/#money_warp.Money-functions","title":"Functions","text":""},{"location":"modules/#money_warp.Money.__init__","title":"<code>__init__(amount)</code>","text":"<p>Create a Money object with high internal precision.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>Union[Decimal, str, int, float]</code> <p>The monetary amount (will be converted to Decimal)</p> required"},{"location":"modules/#money_warp.Money.zero","title":"<code>zero()</code>  <code>classmethod</code>","text":"<p>Create zero money.</p>"},{"location":"modules/#money_warp.Money.from_cents","title":"<code>from_cents(cents)</code>  <code>classmethod</code>","text":"<p>Create from cents to avoid decimal issues.</p>"},{"location":"modules/#money_warp.Money.__add__","title":"<code>__add__(other)</code>","text":"<p>Add two Money objects.</p>"},{"location":"modules/#money_warp.Money.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtract two Money objects.</p>"},{"location":"modules/#money_warp.Money.__mul__","title":"<code>__mul__(factor)</code>","text":"<p>Multiply by a number - keeps high precision.</p>"},{"location":"modules/#money_warp.Money.__truediv__","title":"<code>__truediv__(divisor)</code>","text":"<p>Divide by a number - keeps high precision.</p>"},{"location":"modules/#money_warp.Money.__neg__","title":"<code>__neg__()</code>","text":"<p>Negative money.</p>"},{"location":"modules/#money_warp.Money.__abs__","title":"<code>__abs__()</code>","text":"<p>Absolute value.</p>"},{"location":"modules/#money_warp.Money.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare at 'real money' precision. Accepts Money or Decimal.</p>"},{"location":"modules/#money_warp.Money.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Less than comparison at real money precision. Accepts Money or Decimal.</p>"},{"location":"modules/#money_warp.Money.__le__","title":"<code>__le__(other)</code>","text":"<p>Less than or equal comparison at real money precision. Accepts Money or Decimal.</p>"},{"location":"modules/#money_warp.Money.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Greater than comparison at real money precision. Accepts Money or Decimal.</p>"},{"location":"modules/#money_warp.Money.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Greater than or equal comparison at real money precision. Accepts Money or Decimal.</p>"},{"location":"modules/#money_warp.Money.to_real_money","title":"<code>to_real_money()</code>","text":"<p>Convert to real money (rounded to 2 decimal places).</p>"},{"location":"modules/#money_warp.Money.is_positive","title":"<code>is_positive()</code>","text":"<p>Check if amount is positive.</p>"},{"location":"modules/#money_warp.Money.is_negative","title":"<code>is_negative()</code>","text":"<p>Check if amount is negative.</p>"},{"location":"modules/#money_warp.Money.is_zero","title":"<code>is_zero()</code>","text":"<p>Check if amount is zero.</p>"},{"location":"modules/#money_warp.Money.__str__","title":"<code>__str__()</code>","text":"<p>Display as real money (2 decimal places).</p>"},{"location":"modules/#money_warp.Money.__repr__","title":"<code>__repr__()</code>","text":"<p>Developer representation showing internal precision.</p>"},{"location":"modules/#money_warp.Money.debug_precision","title":"<code>debug_precision()</code>","text":"<p>Show both internal and real amounts for debugging.</p>"},{"location":"modules/#interestrate","title":"InterestRate","text":""},{"location":"modules/#money_warp.InterestRate","title":"<code>money_warp.InterestRate</code>","text":"<p>Represents an interest rate with explicit decimal/percentage handling.</p> <p>Eliminates confusion between 0.05 and 5% by requiring explicit creation methods and providing clear conversions between different compounding frequencies.</p>"},{"location":"modules/#money_warp.InterestRate-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.InterestRate.as_decimal","title":"<code>as_decimal</code>  <code>property</code>","text":"<p>Get as decimal (0.05 = 5%).</p>"},{"location":"modules/#money_warp.InterestRate.as_percentage","title":"<code>as_percentage</code>  <code>property</code>","text":"<p>Get as percentage (5.0 = 5%).</p>"},{"location":"modules/#money_warp.InterestRate.year_size","title":"<code>year_size</code>  <code>property</code>","text":"<p>Day-count convention used for daily conversions.</p>"},{"location":"modules/#money_warp.InterestRate-functions","title":"Functions","text":""},{"location":"modules/#money_warp.InterestRate.__init__","title":"<code>__init__(rate, period=None, as_percentage=False, precision=None, rounding=ROUND_HALF_UP, str_style='long', year_size=YearSize.commercial)</code>","text":"<p>Create an interest rate.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Union[str, Decimal, float]</code> <p>Rate as string (\"5.25% a\", \"0.004167 m\") or numeric value.   Abbreviated formats (\"5.25% a.a.\", \"0.5% a.m.\") are also   accepted and automatically set str_style to \"abbrev\".</p> required <code>period</code> <code>Optional[CompoundingFrequency]</code> <p>Compounding frequency (required if rate is numeric)</p> <code>None</code> <code>as_percentage</code> <code>bool</code> <p>If True and rate is numeric, treat as percentage</p> <code>False</code> <code>precision</code> <code>Optional[int]</code> <p>Number of decimal places for the effective annual rate        during conversions. None keeps full precision.</p> <code>None</code> <code>rounding</code> <code>str</code> <p>Rounding mode from the decimal module (e.g. ROUND_HALF_UP,       ROUND_DOWN). Only used when precision is set.</p> <code>ROUND_HALF_UP</code> <code>str_style</code> <code>str</code> <p>Controls period notation in str. \"long\" outputs the        full name (e.g. \"annually\"), \"abbrev\" outputs the        abbreviated form (e.g. \"a.a.\").</p> <code>'long'</code> <code>year_size</code> <code>YearSize</code> <p>Day-count convention for daily conversions.        YearSize.commercial (365) or YearSize.banker (360).</p> <code>commercial</code>"},{"location":"modules/#money_warp.InterestRate.to_daily","title":"<code>to_daily()</code>","text":"<p>Convert to daily rate.</p>"},{"location":"modules/#money_warp.InterestRate.to_monthly","title":"<code>to_monthly()</code>","text":"<p>Convert to monthly rate.</p>"},{"location":"modules/#money_warp.InterestRate.to_annual","title":"<code>to_annual()</code>","text":"<p>Convert to annual rate.</p>"},{"location":"modules/#money_warp.InterestRate.to_periodic_rate","title":"<code>to_periodic_rate(num_periods)</code>","text":"<p>Convert to periodic rate for given number of periods per year.</p> <p>Parameters:</p> Name Type Description Default <code>num_periods</code> <code>int</code> <p>Number of periods per year (e.g., 12 for monthly)</p> required <p>Returns:</p> Name Type Description <code>Decimal</code> <code>Decimal</code> <p>Periodic rate as decimal</p>"},{"location":"modules/#money_warp.InterestRate.accrue","title":"<code>accrue(principal, days)</code>","text":"<p>Compute compound interest accrued on a principal over a number of days.</p> <p>Formula: principal * ((1 + daily_rate) ** days - 1)</p> <p>Parameters:</p> Name Type Description Default <code>principal</code> <code>Money</code> <p>The principal amount.</p> required <code>days</code> <code>int</code> <p>Number of days to accrue interest over.</p> required <p>Returns:</p> Type Description <code>Money</code> <p>The accrued interest (not including the principal).</p>"},{"location":"modules/#money_warp.InterestRate.__str__","title":"<code>__str__()</code>","text":"<p>Clear string representation.</p>"},{"location":"modules/#money_warp.InterestRate.__repr__","title":"<code>__repr__()</code>","text":"<p>Developer representation.</p>"},{"location":"modules/#money_warp.InterestRate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare rates by converting to effective annual.</p>"},{"location":"modules/#money_warp.InterestRate.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Less than comparison using effective annual rates.</p>"},{"location":"modules/#money_warp.InterestRate.__le__","title":"<code>__le__(other)</code>","text":"<p>Less than or equal comparison using effective annual rates.</p>"},{"location":"modules/#money_warp.InterestRate.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Greater than comparison using effective annual rates.</p>"},{"location":"modules/#money_warp.InterestRate.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Greater than or equal comparison using effective annual rates.</p>"},{"location":"modules/#cashflow","title":"CashFlow","text":""},{"location":"modules/#money_warp.CashFlow","title":"<code>money_warp.CashFlow</code>","text":"<p>Container for a collection of cash flow items representing a financial stream.</p> <p>Internally stores :class:<code>CashFlowItem</code> (temporal containers). Public iteration and query methods resolve each item and filter out deleted entries, so consumers see only active :class:<code>CashFlowEntry</code> objects.</p>"},{"location":"modules/#money_warp.CashFlow-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.CashFlow.query","title":"<code>query</code>  <code>property</code>","text":"<p>Create a query builder over active entries.</p>"},{"location":"modules/#money_warp.CashFlow-functions","title":"Functions","text":""},{"location":"modules/#money_warp.CashFlow.empty","title":"<code>empty()</code>  <code>classmethod</code>","text":"<p>Create an empty cash flow.</p>"},{"location":"modules/#money_warp.CashFlow.add_item","title":"<code>add_item(item)</code>","text":"<p>Add a cash flow item to this stream.</p>"},{"location":"modules/#money_warp.CashFlow.add","title":"<code>add(amount, datetime, description=None, category=None)</code>","text":"<p>Add a cash flow item by specifying its components.</p>"},{"location":"modules/#money_warp.CashFlow.items","title":"<code>items()</code>","text":"<p>Active entries at the current time (resolves and filters).</p>"},{"location":"modules/#money_warp.CashFlow.sorted_items","title":"<code>sorted_items()</code>","text":"<p>Active entries sorted by datetime.</p>"},{"location":"modules/#money_warp.CashFlow.raw_items","title":"<code>raw_items()</code>","text":"<p>Underlying temporal containers (use for update/delete).</p>"},{"location":"modules/#money_warp.CashFlow.net_present_value","title":"<code>net_present_value()</code>","text":"<p>Simple sum of all active cash flows (no discounting).</p>"},{"location":"modules/#money_warp.CashFlow.total_inflows","title":"<code>total_inflows()</code>","text":"<p>Sum of all positive cash flows.</p>"},{"location":"modules/#money_warp.CashFlow.total_outflows","title":"<code>total_outflows()</code>","text":"<p>Sum of all negative cash flows (returned as positive amount).</p>"},{"location":"modules/#money_warp.CashFlow.filter_by_category","title":"<code>filter_by_category(category)</code>","text":"<p>New CashFlow containing only items with the specified category.</p>"},{"location":"modules/#money_warp.CashFlow.filter_by_datetime_range","title":"<code>filter_by_datetime_range(start_datetime, end_datetime)</code>","text":"<p>New CashFlow containing only items within the datetime range.</p>"},{"location":"modules/#cashflowitem","title":"CashFlowItem","text":""},{"location":"modules/#money_warp.CashFlowItem","title":"<code>money_warp.CashFlowItem</code>","text":"<p>Temporal container that wraps a timeline of :class:<code>CashFlowEntry</code> snapshots.</p> <p>At any point in time exactly one entry (or <code>None</code>, meaning deleted) is active.  :meth:<code>resolve</code> returns that entry for <code>self.now()</code>.</p> <p>The constructor accepts the same positional/keyword arguments as the old <code>CashFlowItem</code> so that existing call-sites continue to work without changes during the migration.</p>"},{"location":"modules/#money_warp.CashFlowItem-functions","title":"Functions","text":""},{"location":"modules/#money_warp.CashFlowItem.resolve","title":"<code>resolve()</code>","text":"<p>Return the active entry at <code>self.now()</code>, or <code>None</code> if deleted.</p>"},{"location":"modules/#money_warp.CashFlowItem.update","title":"<code>update(effective_date, new_entry)</code>","text":"<p>From effective_date onward this item resolves to new_entry.</p>"},{"location":"modules/#money_warp.CashFlowItem.delete","title":"<code>delete(effective_date)</code>","text":"<p>From effective_date onward this item resolves to <code>None</code>.</p>"},{"location":"modules/#loan","title":"Loan","text":""},{"location":"modules/#money_warp.Loan","title":"<code>money_warp.Loan</code>","text":"<p>Represents a personal loan as a state machine with late payment fine support.</p> <p>Delegates complex calculations to a configurable scheduler and focuses on state management and tracking actual payments. Supports configurable late payment fines with grace periods.</p> <p>Features: - Flexible payment schedules using configurable schedulers - Automatic payment allocation: Fines \u2192 Interest \u2192 Principal - Configurable fines (default 2% of missed payment) - Configurable grace periods before fines apply - Time-aware fine calculation and application - Comprehensive cash flow tracking including fine events</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Loan, Money, InterestRate\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Basic loan with default fine settings\n&gt;&gt;&gt; loan = Loan(\n...     Money(\"10000\"),\n...     InterestRate(\"5% annual\"),\n...     [datetime(2024, 2, 1), datetime(2024, 3, 1)]\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Loan with custom fine settings\n&gt;&gt;&gt; loan = Loan(\n...     Money(\"10000\"),\n...     InterestRate(\"5% annual\"),\n...     [datetime(2024, 2, 1)],\n...     fine_rate=Decimal(\"0.05\"),  # 5% fine\n...     grace_period_days=7  # 7-day grace period\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check for late payments and apply fines\n&gt;&gt;&gt; fines = loan.calculate_late_fines(datetime(2024, 2, 10))\n&gt;&gt;&gt; print(f\"Fines applied: {fines}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Make payment (automatically allocated to fines first)\n&gt;&gt;&gt; loan.record_payment(Money(\"500\"), datetime(2024, 2, 11))\n&gt;&gt;&gt; print(f\"Outstanding fines: {loan.outstanding_fines}\")\n</code></pre>"},{"location":"modules/#money_warp.Loan-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.Loan.principal_balance","title":"<code>principal_balance</code>  <code>property</code>","text":"<p>Get the current principal balance (original principal minus principal payments).</p>"},{"location":"modules/#money_warp.Loan.accrued_interest","title":"<code>accrued_interest</code>  <code>property</code>","text":"<p>Get the current accrued interest since last payment.</p> <p>Respects <code>mora_interest_rate</code> and <code>mora_strategy</code> when the borrower is past the next unpaid due date.</p>"},{"location":"modules/#money_warp.Loan.current_balance","title":"<code>current_balance</code>  <code>property</code>","text":"<p>Get the current outstanding balance including principal, accrued interest, and fines.</p>"},{"location":"modules/#money_warp.Loan.is_paid_off","title":"<code>is_paid_off</code>  <code>property</code>","text":"<p>Check if the loan is fully paid off, including all fines.</p>"},{"location":"modules/#money_warp.Loan.last_payment_date","title":"<code>last_payment_date</code>  <code>property</code>","text":"<p>Get the date of the last payment made, or disbursement date if no payments.</p>"},{"location":"modules/#money_warp.Loan.total_fines","title":"<code>total_fines</code>  <code>property</code>","text":"<p>Get the total amount of fines applied to this loan.</p>"},{"location":"modules/#money_warp.Loan.outstanding_fines","title":"<code>outstanding_fines</code>  <code>property</code>","text":"<p>Get the current unpaid fine amount.</p>"},{"location":"modules/#money_warp.Loan.tax_amounts","title":"<code>tax_amounts</code>  <code>property</code>","text":"<p>Per-tax results keyed by tax class name. Computed lazily and cached.</p>"},{"location":"modules/#money_warp.Loan.total_tax","title":"<code>total_tax</code>  <code>property</code>","text":"<p>Sum of all taxes applied to this loan.</p>"},{"location":"modules/#money_warp.Loan.net_disbursement","title":"<code>net_disbursement</code>  <code>property</code>","text":"<p>Amount the borrower actually receives (principal minus total tax).</p>"},{"location":"modules/#money_warp.Loan.settlements","title":"<code>settlements</code>  <code>property</code>","text":"<p>All settlements made on this loan, reconstructed from the cash flow.</p> <p>Warp-aware: only includes settlements whose payment_date is at or before self.now().</p>"},{"location":"modules/#money_warp.Loan.installments","title":"<code>installments</code>  <code>property</code>","text":"<p>The repayment plan as a list of Installments.</p> <p>Built from the original schedule with actual payment allocations gathered from settlements. Reflects the current time context (Warp-aware): installments show as paid only if the corresponding settlements have occurred by self.now().</p> <p>Each installment carries expected_mora and expected_fine so its balance (and derived is_fully_paid) are self-contained.</p>"},{"location":"modules/#money_warp.Loan-functions","title":"Functions","text":""},{"location":"modules/#money_warp.Loan.__init__","title":"<code>__init__(principal, interest_rate, due_dates, disbursement_date=None, scheduler=None, fine_rate=None, grace_period_days=0, mora_interest_rate=None, mora_strategy=MoraStrategy.COMPOUND, taxes=None, is_grossed_up=False)</code>","text":"<p>Create a loan with flexible payment schedule.</p> <p>Parameters:</p> Name Type Description Default <code>principal</code> <code>Money</code> <p>The loan amount</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The annual interest rate</p> required <code>due_dates</code> <code>List[datetime]</code> <p>List of payment due dates (flexible scheduling)</p> required <code>disbursement_date</code> <code>Optional[datetime]</code> <p>When the loan was disbursed (defaults to now). Must be before the first due date.</p> <code>None</code> <code>scheduler</code> <code>Optional[Type[BaseScheduler]]</code> <p>Scheduler class to use for calculations (defaults to PriceScheduler)</p> <code>None</code> <code>fine_rate</code> <code>Optional[Decimal]</code> <p>Fine as decimal fraction of missed payment (defaults to 0.02 for 2%)</p> <code>None</code> <code>grace_period_days</code> <code>int</code> <p>Days after due date before fines apply (defaults to 0)</p> <code>0</code> <code>mora_interest_rate</code> <code>Optional[InterestRate]</code> <p>Interest rate for mora (late) interest (defaults to interest_rate)</p> <code>None</code> <code>mora_strategy</code> <code>MoraStrategy</code> <p>How mora interest is computed (defaults to COMPOUND)</p> <code>COMPOUND</code> <code>taxes</code> <code>Optional[List[BaseTax]]</code> <p>Optional list of taxes applied to this loan (e.g., IOF)</p> <code>None</code> <code>is_grossed_up</code> <code>bool</code> <p>Whether the principal was grossed up to absorb taxes. When True, generate_expected_cash_flow() omits the separate tax entry because the tax is already reflected in the higher principal.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic loan with default 2% fine, no grace period\n&gt;&gt;&gt; loan = Loan(Money(\"10000\"), InterestRate(\"5% annual\"),\n...            [datetime(2024, 2, 1)])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Loan with custom 5% fine and 3-day grace period\n&gt;&gt;&gt; loan = Loan(Money(\"10000\"), InterestRate(\"5% annual\"),\n...            [datetime(2024, 2, 1)],\n...            fine_rate=Decimal(\"0.05\"), grace_period_days=3)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Loan with separate mora interest rate\n&gt;&gt;&gt; loan = Loan(Money(\"10000\"), InterestRate(\"5% annual\"),\n...            [datetime(2024, 2, 1)],\n...            mora_interest_rate=InterestRate(\"12% annual\"))\n</code></pre>"},{"location":"modules/#money_warp.Loan.now","title":"<code>now()</code>","text":"<p>Current datetime (Warp-aware via shared TimeContext).</p>"},{"location":"modules/#money_warp.Loan.date","title":"<code>date()</code>","text":"<p>Current datetime (Warp-aware via shared TimeContext).</p>"},{"location":"modules/#money_warp.Loan.days_since_last_payment","title":"<code>days_since_last_payment(as_of_date=None)</code>","text":"<p>Get the number of days since the last payment as of a given date (defaults to current time).</p>"},{"location":"modules/#money_warp.Loan.get_expected_payment_amount","title":"<code>get_expected_payment_amount(due_date)</code>","text":"<p>Get the expected payment amount for a specific due date from the original schedule.</p> <p>This always references the original loan terms (not the rebuilt schedule), which is important for fine calculations.</p> <p>Parameters:</p> Name Type Description Default <code>due_date</code> <code>datetime</code> <p>The due date to get the expected payment for</p> required <p>Returns:</p> Type Description <code>Money</code> <p>The expected payment amount for that due date</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the due date is not in the loan's due dates</p>"},{"location":"modules/#money_warp.Loan.is_payment_late","title":"<code>is_payment_late(due_date, as_of_date=None)</code>","text":"<p>Check if a payment is late considering the grace period.</p> <p>Parameters:</p> Name Type Description Default <code>due_date</code> <code>datetime</code> <p>The payment due date to check</p> required <code>as_of_date</code> <code>Optional[datetime]</code> <p>The date to check against (defaults to current time)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the payment is late (past due date + grace period), False otherwise</p>"},{"location":"modules/#money_warp.Loan.calculate_late_fines","title":"<code>calculate_late_fines(as_of_date=None)</code>","text":"<p>Calculate and apply late payment fines for any new late payments.</p> <p>Parameters:</p> Name Type Description Default <code>as_of_date</code> <code>Optional[datetime]</code> <p>The date to calculate fines as of (defaults to current time)</p> <code>None</code> <p>Returns:</p> Type Description <code>Money</code> <p>The total amount of new fines applied</p>"},{"location":"modules/#money_warp.Loan.present_value","title":"<code>present_value(discount_rate=None, valuation_date=None)</code>","text":"<p>Calculate the Present Value of the loan's expected cash flows.</p> <p>This is a convenience method that generates the expected cash flow and calculates its present value. By default, uses the loan's own interest rate as the discount rate.</p> <p>Parameters:</p> Name Type Description Default <code>discount_rate</code> <code>Optional[InterestRate]</code> <p>The discount rate to use (defaults to loan's interest rate)</p> <code>None</code> <code>valuation_date</code> <code>Optional[datetime]</code> <p>Date to discount back to (defaults to current time)</p> <code>None</code> <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the loan's expected cash flows</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Loan, Money, InterestRate\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; loan = Loan(Money(\"10000\"), InterestRate(\"5% annual\"),\n...            [datetime(2024, 1, 15), datetime(2024, 2, 15)])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get present value using loan's own rate (should be close to zero)\n&gt;&gt;&gt; pv = loan.present_value()\n&gt;&gt;&gt; print(f\"Loan PV at its own rate: {pv}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get present value using different discount rate\n&gt;&gt;&gt; pv = loan.present_value(InterestRate(\"8% annual\"))\n&gt;&gt;&gt; print(f\"Loan PV at 8%: {pv}\")\n</code></pre>"},{"location":"modules/#money_warp.Loan.irr","title":"<code>irr(guess=None)</code>","text":"<p>Calculate the Internal Rate of Return (IRR) of the loan's expected cash flows.</p> <p>This is a convenience method that generates the expected cash flow and calculates its IRR. The IRR represents the effective rate of return of the loan from the borrower's perspective.</p> <p>Note: To calculate IRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     irr = warped_loan.irr()</p> <p>Parameters:</p> Name Type Description Default <code>guess</code> <code>Optional[InterestRate]</code> <p>Initial guess for IRR (defaults to 10% annual)</p> <code>None</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The internal rate of return of the loan's expected cash flows</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Loan, Money, InterestRate, Warp\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt;\n&gt;&gt;&gt; loan = Loan(Money(\"10000\"), InterestRate(\"5% annual\"),\n...            [datetime(2024, 1, 15), datetime(2024, 2, 15)])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get IRR - should be close to loan's interest rate\n&gt;&gt;&gt; loan_irr = loan.irr()\n&gt;&gt;&gt; print(f\"Loan IRR: {loan_irr}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get IRR from a specific date using Time Machine\n&gt;&gt;&gt; with Warp(loan, datetime(2024, 1, 10)) as warped_loan:\n...     past_irr = warped_loan.irr()\n&gt;&gt;&gt; print(f\"IRR from past perspective: {past_irr}\")\n</code></pre>"},{"location":"modules/#money_warp.Loan.generate_expected_cash_flow","title":"<code>generate_expected_cash_flow()</code>","text":"<p>Generate the expected payment schedule without fines.</p> <p>This represents the original loan terms and expected payments. Fines are contingent events and are not included in the expected cash flow. Use get_actual_cash_flow() to see what actually happened, including fines.</p> <p>When taxes are present on a non-grossed-up loan, the full principal is the disbursement entry and the tax appears as a separate outflow, so the day-0 net equals net_disbursement.  For grossed-up loans the tax is already absorbed into the higher principal, so only net_disbursement (= requested amount) is emitted with no separate tax entry.</p> <p>Returns:</p> Type Description <code>CashFlow</code> <p>CashFlow with loan disbursement and expected payment schedule</p>"},{"location":"modules/#money_warp.Loan.record_payment","title":"<code>record_payment(amount, payment_date, interest_date=None, processing_date=None, description=None)</code>","text":"<p>Record an actual payment made on the loan with automatic allocation.</p> <p>Payment allocation priority: Fines -&gt; Interest -&gt; Principal</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>Money</code> <p>Total payment amount (positive value)</p> required <code>payment_date</code> <code>datetime</code> <p>When the money moved</p> required <code>interest_date</code> <code>Optional[datetime]</code> <p>Cutoff date for interest accrual calculation. Defaults to payment_date (borrower gets discount for early payment).</p> <code>None</code> <code>processing_date</code> <code>Optional[datetime]</code> <p>When the system recorded the event (audit trail). Defaults to self.now().</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description of the payment</p> <code>None</code> <p>Returns:</p> Type Description <code>Settlement</code> <p>Settlement describing how the payment was allocated.</p>"},{"location":"modules/#money_warp.Loan.pay_installment","title":"<code>pay_installment(amount, description=None)</code>","text":"<p>Pay the next installment.</p> <p>Interest accrual depends on timing relative to the due date: - Early/on-time: interest accrues up to the due date (no discount). - Late: interest accrues up to self.now(), so the borrower pays extra   interest for the additional days beyond the due date.</p> <p>This is the most common payment method and works correctly whether the borrower pays early, on time, or late.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>Money</code> <p>Total payment amount (positive value)</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the payment</p> <code>None</code> <p>Returns:</p> Type Description <code>Settlement</code> <p>Settlement describing how the payment was allocated.</p>"},{"location":"modules/#money_warp.Loan.anticipate_payment","title":"<code>anticipate_payment(amount, installments=None, description=None)</code>","text":"<p>Make an early payment with interest discount.</p> <p>Interest is calculated only up to <code>self.now()</code>, so the borrower pays less interest for fewer elapsed days.</p> <p>When installments is provided (1-based installment numbers), the corresponding expected cash-flow items are temporally deleted so that <code>due_dates</code> and future schedules no longer include them.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>Money</code> <p>Total payment amount (positive value).</p> required <code>installments</code> <code>Optional[List[int]]</code> <p>Optional 1-based installment numbers to remove.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description of the payment.</p> <code>None</code> <p>Returns:</p> Type Description <code>Settlement</code> <p>Settlement describing how the payment was allocated.</p>"},{"location":"modules/#money_warp.Loan.calculate_anticipation","title":"<code>calculate_anticipation(installments)</code>","text":"<p>Calculate the amount to pay today to eliminate specific installments.</p> <p>Pure calculation \u2014 no side effects on the loan.</p> The maths <p>sustainable_balance = PV(kept payments at kept dates) anticipation_amount = current_balance - sustainable_balance</p> <p>Parameters:</p> Name Type Description Default <code>installments</code> <code>List[int]</code> <p>1-based installment numbers to anticipate.</p> required <p>Returns:</p> Type Description <code>AnticipationResult</code> <p>class:<code>AnticipationResult</code> with the amount and the</p> <code>AnticipationResult</code> <p>installment objects being removed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any number is invalid or already paid.</p>"},{"location":"modules/#money_warp.Loan.get_actual_cash_flow","title":"<code>get_actual_cash_flow()</code>","text":"<p>Get the actual cash flow combining expected schedule with actual payments made.</p> <p>This shows both what was expected and what actually happened for comparison. Includes fine applications and fine payments.</p>"},{"location":"modules/#money_warp.Loan.get_original_schedule","title":"<code>get_original_schedule()</code>","text":"<p>Get the original amortization schedule as calculated at loan origination.</p> <p>This always returns the static schedule based on the original loan terms, ignoring any payments that have been made.</p> <p>Returns:</p> Type Description <code>PaymentSchedule</code> <p>PaymentSchedule based on original loan parameters</p>"},{"location":"modules/#money_warp.Loan.get_amortization_schedule","title":"<code>get_amortization_schedule()</code>","text":"<p>Get the current amortization schedule merging actual past with projected future.</p> <p>Returns a clean, ordered list: recorded payment entries first, then projected entries recalculated from the remaining principal and remaining due dates with a new PMT.</p> <p>If no payments have been made, returns the original schedule.</p> <p>Returns:</p> Type Description <code>PaymentSchedule</code> <p>PaymentSchedule with past entries followed by projected future entries</p>"},{"location":"modules/#money_warp.Loan.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the loan.</p>"},{"location":"modules/#money_warp.Loan.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed representation for debugging.</p>"},{"location":"modules/#time-machine","title":"Time Machine","text":""},{"location":"modules/#warp","title":"Warp","text":""},{"location":"modules/#money_warp.Warp","title":"<code>money_warp.Warp</code>","text":"<p>Time Machine context manager for financial projections and analysis.</p> <p>Allows you to temporarily \"warp\" a loan to a specific date to analyze its state at that point in time. This is useful for: - Calculating loan balances at future dates - Analyzing payment history up to a past date - Creating \"what if\" scenarios at different points in time</p> Usage <p>loan = Loan(...) with Warp(loan, '2030-01-15') as warped_loan:     balance = warped_loan.current_balance</p> <p>Note: Nested Warp contexts are not allowed for safety.</p>"},{"location":"modules/#money_warp.Warp-functions","title":"Functions","text":""},{"location":"modules/#money_warp.Warp.__init__","title":"<code>__init__(loan, target_date)</code>","text":"<p>Initialize the Warp context manager.</p> <p>Parameters:</p> Name Type Description Default <code>loan</code> <code>Loan</code> <p>The loan object to warp</p> required <code>target_date</code> <code>Union[str, date, datetime]</code> <p>The date to warp to (accepts strings, date, or datetime objects)</p> required <p>Raises:</p> Type Description <code>NestedWarpError</code> <p>If another Warp context is already active</p> <code>InvalidDateError</code> <p>If the target_date cannot be parsed</p>"},{"location":"modules/#money_warp.Warp.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the Warp context and return a time-warped loan.</p> <p>Returns:</p> Type Description <code>Loan</code> <p>A cloned loan with its state modified to reflect the target date</p>"},{"location":"modules/#money_warp.Warp.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the Warp context and clean up.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>Exception type (if any)</p> required <code>exc_val</code> <code>Optional[BaseException]</code> <p>Exception value (if any)</p> required <code>exc_tb</code> <code>Optional[object]</code> <p>Exception traceback (if any)</p> required"},{"location":"modules/#money_warp.Warp.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the Warp.</p>"},{"location":"modules/#money_warp.Warp.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed representation for debugging.</p>"},{"location":"modules/#warpedtime","title":"WarpedTime","text":""},{"location":"modules/#money_warp.warp.WarpedTime","title":"<code>money_warp.warp.WarpedTime</code>","text":"<p>Warped time source that returns a fixed time for time travel scenarios.</p>"},{"location":"modules/#money_warp.warp.WarpedTime-functions","title":"Functions","text":""},{"location":"modules/#money_warp.warp.WarpedTime.now","title":"<code>now()</code>","text":"<p>Return the fixed datetime instead of current time.</p>"},{"location":"modules/#money_warp.warp.WarpedTime.date","title":"<code>date()</code>","text":"<p>Return the fixed date instead of current date.</p>"},{"location":"modules/#exceptions","title":"Exceptions","text":""},{"location":"modules/#warperror","title":"WarpError","text":""},{"location":"modules/#money_warp.WarpError","title":"<code>money_warp.WarpError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Warp-related errors.</p>"},{"location":"modules/#nestedwarperror","title":"NestedWarpError","text":""},{"location":"modules/#money_warp.NestedWarpError","title":"<code>money_warp.NestedWarpError</code>","text":"<p>               Bases: <code>WarpError</code></p> <p>Raised when attempting to create nested Warp contexts.</p>"},{"location":"modules/#invaliddateerror","title":"InvalidDateError","text":""},{"location":"modules/#money_warp.InvalidDateError","title":"<code>money_warp.InvalidDateError</code>","text":"<p>               Bases: <code>WarpError</code></p> <p>Raised when an invalid date is provided to Warp.</p>"},{"location":"modules/#schedulers","title":"Schedulers","text":""},{"location":"modules/#pricescheduler","title":"PriceScheduler","text":""},{"location":"modules/#money_warp.PriceScheduler","title":"<code>money_warp.PriceScheduler</code>","text":"<p>               Bases: <code>BaseScheduler</code></p> <p>Price scheduler implementing Progressive Price Schedule (French amortization system).</p> <p>This scheduler calculates a fixed payment amount (PMT) and then allocates each payment between interest and principal. Interest is calculated on the outstanding balance, and the remainder goes to principal reduction.</p> <p>Based on the reference implementation from cartaorobbin/loan-calculator.</p>"},{"location":"modules/#money_warp.PriceScheduler-functions","title":"Functions","text":""},{"location":"modules/#money_warp.PriceScheduler.__init__","title":"<code>__init__(principal=None, daily_interest_rate=None, return_days=None, disbursement_date=None)</code>","text":"<p>Initialize the scheduler with loan parameters.</p>"},{"location":"modules/#money_warp.PriceScheduler.generate_schedule","title":"<code>generate_schedule(principal, interest_rate, due_dates, disbursement_date)</code>  <code>classmethod</code>","text":"<p>Generate Progressive Price Schedule with fixed payment amounts.</p> <p>Parameters:</p> Name Type Description Default <code>principal</code> <code>Money</code> <p>The loan amount</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The annual interest rate</p> required <code>due_dates</code> <code>List[datetime]</code> <p>List of payment due dates</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan was disbursed</p> required <p>Returns:</p> Type Description <code>PaymentSchedule</code> <p>PaymentSchedule with fixed payment amounts and interest/principal allocation</p>"},{"location":"modules/#money_warp.PriceScheduler.calculate_constant_return_pmt","title":"<code>calculate_constant_return_pmt()</code>","text":"<p>Calculate PMT using the reference formula from loan-calculator.</p> <p>PMT = principal / sum(1 / (1 + daily_rate)^n for n in return_days)</p> <p>Returns:</p> Type Description <code>Decimal</code> <p>The fixed payment amount (PMT)</p>"},{"location":"modules/#invertedpricescheduler","title":"InvertedPriceScheduler","text":""},{"location":"modules/#money_warp.InvertedPriceScheduler","title":"<code>money_warp.InvertedPriceScheduler</code>","text":"<p>               Bases: <code>BaseScheduler</code></p> <p>Inverted Price scheduler implementing Constant Amortization System (SAC).</p> <p>This scheduler calculates a fixed principal payment amount for each period and adds variable interest calculated on the outstanding balance. This results in decreasing total payments over time.</p> <p>Key characteristics: - Fixed principal payment each period - Variable interest payment (decreases over time) - Variable total payment (decreases over time) - Faster debt reduction compared to Price scheduler</p>"},{"location":"modules/#money_warp.InvertedPriceScheduler-functions","title":"Functions","text":""},{"location":"modules/#money_warp.InvertedPriceScheduler.generate_schedule","title":"<code>generate_schedule(principal, interest_rate, due_dates, disbursement_date)</code>  <code>classmethod</code>","text":"<p>Generate Constant Amortization Schedule with fixed principal payments.</p> <p>Parameters:</p> Name Type Description Default <code>principal</code> <code>Money</code> <p>The loan amount</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The annual interest rate</p> required <code>due_dates</code> <code>List[datetime]</code> <p>List of payment due dates</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan was disbursed</p> required <p>Returns:</p> Type Description <code>PaymentSchedule</code> <p>PaymentSchedule with fixed principal amounts and variable total payments</p>"},{"location":"modules/#basescheduler","title":"BaseScheduler","text":""},{"location":"modules/#money_warp.BaseScheduler","title":"<code>money_warp.BaseScheduler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all payment schedulers.</p> <p>All schedulers should inherit from this and implement the generate_schedule class method.</p>"},{"location":"modules/#money_warp.BaseScheduler-functions","title":"Functions","text":""},{"location":"modules/#money_warp.BaseScheduler.generate_schedule","title":"<code>generate_schedule(principal, interest_rate, due_dates, disbursement_date)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Generate the payment schedule.</p> <p>This is the only public method that schedulers need to implement.</p> <p>Parameters:</p> Name Type Description Default <code>principal</code> <code>Money</code> <p>The loan amount</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The annual interest rate</p> required <code>due_dates</code> <code>List[datetime]</code> <p>List of payment due dates</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan was disbursed</p> required <p>Returns:</p> Type Description <code>PaymentSchedule</code> <p>PaymentSchedule with all payment details</p>"},{"location":"modules/#installment-settlement","title":"Installment &amp; Settlement","text":""},{"location":"modules/#installment","title":"Installment","text":""},{"location":"modules/#money_warp.Installment","title":"<code>money_warp.Installment</code>  <code>dataclass</code>","text":"<p>A single installment in a loan repayment plan.</p> <p>Represents the borrower's obligation for one period: what is expected, what has actually been paid, and the detailed per-payment allocations.</p> <p>Installments are consequences of the loan -- they describe HOW the borrower repays, not what defines the loan itself. The Loan builds these on demand as a live snapshot reflecting the current time context.</p>"},{"location":"modules/#money_warp.Installment-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.Installment.balance","title":"<code>balance</code>  <code>property</code>","text":"<p>The amount still owed to fully settle this installment.</p>"},{"location":"modules/#money_warp.Installment.is_fully_paid","title":"<code>is_fully_paid</code>  <code>property</code>","text":"<p>Whether this installment has been fully settled.</p>"},{"location":"modules/#money_warp.Installment-functions","title":"Functions","text":""},{"location":"modules/#money_warp.Installment.from_schedule_entry","title":"<code>from_schedule_entry(entry, allocations, expected_mora, expected_fine)</code>  <code>classmethod</code>","text":"<p>Build an Installment from a scheduler's PaymentScheduleEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>PaymentScheduleEntry</code> <p>The schedule entry from the scheduler.</p> required <code>allocations</code> <code>List[SettlementAllocation]</code> <p>SettlementAllocations attributed to this installment.</p> required <code>expected_mora</code> <code>Money</code> <p>Mora interest owed for this installment.</p> required <code>expected_fine</code> <code>Money</code> <p>Fine amount owed for this installment.</p> required"},{"location":"modules/#settlement","title":"Settlement","text":""},{"location":"modules/#money_warp.Settlement","title":"<code>money_warp.Settlement</code>  <code>dataclass</code>","text":"<p>Result of applying a payment to a loan.</p> <p>Captures the full allocation of a single payment across fines, interest, mora interest, and principal, along with per-installment detail showing which installments were covered.</p>"},{"location":"modules/#settlementallocation","title":"SettlementAllocation","text":""},{"location":"modules/#money_warp.SettlementAllocation","title":"<code>money_warp.SettlementAllocation</code>  <code>dataclass</code>","text":"<p>Breakdown of a payment's allocation to a single installment.</p> <p>Each allocation shows how much principal, interest, mora, and fine from a payment were attributed to a specific installment.</p>"},{"location":"modules/#data-classes","title":"Data Classes","text":""},{"location":"modules/#paymentschedule","title":"PaymentSchedule","text":""},{"location":"modules/#money_warp.PaymentSchedule","title":"<code>money_warp.PaymentSchedule</code>  <code>dataclass</code>","text":"<p>Complete payment schedule for a loan.</p> <p>Contains all payment entries and summary information.</p>"},{"location":"modules/#money_warp.PaymentSchedule-functions","title":"Functions","text":""},{"location":"modules/#money_warp.PaymentSchedule.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Calculate totals after initialization.</p>"},{"location":"modules/#money_warp.PaymentSchedule.__len__","title":"<code>__len__()</code>","text":"<p>Number of payments in the schedule.</p>"},{"location":"modules/#money_warp.PaymentSchedule.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get payment entry by index.</p>"},{"location":"modules/#money_warp.PaymentSchedule.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over payment entries.</p>"},{"location":"modules/#money_warp.PaymentSchedule.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the schedule.</p>"},{"location":"modules/#paymentscheduleentry","title":"PaymentScheduleEntry","text":""},{"location":"modules/#money_warp.PaymentScheduleEntry","title":"<code>money_warp.PaymentScheduleEntry</code>  <code>dataclass</code>","text":"<p>Represents a single payment in an amortization schedule.</p> <p>This is the standard structure that all schedulers should return.</p>"},{"location":"modules/#money_warp.PaymentScheduleEntry-functions","title":"Functions","text":""},{"location":"modules/#money_warp.PaymentScheduleEntry.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the payment entry.</p>"},{"location":"modules/#query-interface","title":"Query Interface","text":""},{"location":"modules/#cashflowquery","title":"CashFlowQuery","text":""},{"location":"modules/#money_warp.CashFlowQuery","title":"<code>money_warp.CashFlowQuery</code>","text":"<p>SQLAlchemy-style query builder for filtering cash flow entries.</p> <p>Works with both :class:<code>CashFlowEntry</code> and :class:<code>CashFlowItem</code> objects \u2014 both expose the same attribute interface (<code>amount</code>, <code>datetime</code>, <code>description</code>, <code>category</code>).</p>"},{"location":"modules/#money_warp.CashFlowQuery-functions","title":"Functions","text":""},{"location":"modules/#money_warp.CashFlowQuery.filter_by","title":"<code>filter_by(predicate=None, **kwargs)</code>","text":"<p>Filter items using keyword arguments or a predicate function.</p> <p>Keyword arguments: - category: Filter by category - amount / amount__gt / amount__gte / amount__lt / amount__lte - datetime / datetime__gt / datetime__gte / datetime__lt / datetime__lte - description: Filter by description - is_inflow: Filter to only inflows (True) or outflows (False)</p>"},{"location":"modules/#money_warp.CashFlowQuery.order_by","title":"<code>order_by(*fields)</code>","text":"<p>Order items by one or more fields.</p> <p>Prefix with '-' for descending: '-datetime', '-amount'.</p>"},{"location":"modules/#money_warp.CashFlowQuery.to_cash_flow","title":"<code>to_cash_flow()</code>","text":"<p>Convert query result back to a CashFlow.</p> <p>If the query holds :class:<code>CashFlowEntry</code> objects they are wrapped in fresh :class:<code>CashFlowItem</code> containers.</p>"},{"location":"modules/#enums","title":"Enums","text":""},{"location":"modules/#compoundingfrequency","title":"CompoundingFrequency","text":""},{"location":"modules/#money_warp.CompoundingFrequency","title":"<code>money_warp.CompoundingFrequency</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Frequency of compounding per year.</p>"},{"location":"modules/#yearsize","title":"YearSize","text":""},{"location":"modules/#money_warp.YearSize","title":"<code>money_warp.YearSize</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Number of days that constitute one year for rate conversions.</p>"},{"location":"modules/#present-value-functions","title":"Present Value Functions","text":""},{"location":"modules/#present_value","title":"present_value","text":""},{"location":"modules/#money_warp.present_value","title":"<code>money_warp.present_value</code>","text":"<p>Present Value and IRR calculations for cash flows and financial instruments.</p>"},{"location":"modules/#money_warp.present_value-classes","title":"Classes","text":""},{"location":"modules/#money_warp.present_value-functions","title":"Functions","text":""},{"location":"modules/#money_warp.present_value.present_value","title":"<code>present_value(cash_flow, discount_rate, valuation_date=None)</code>","text":"<p>Calculate the Present Value (PV) of a cash flow stream.</p> <p>The Present Value is the sum of all future cash flows discounted back to the valuation date using the specified discount rate.</p> <p>Formula: PV = \u03a3(CF_t / (1 + r)^t) where: - CF_t = Cash flow at time t - r = Discount rate per period - t = Time periods from valuation date</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to evaluate</p> required <code>discount_rate</code> <code>InterestRate</code> <p>The discount rate to use for discounting</p> required <code>valuation_date</code> <code>Optional[datetime]</code> <p>Date to discount back to (defaults to earliest cash flow date)</p> <code>None</code> <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the cash flow stream</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, InterestRate, present_value\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a simple cash flow\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"1000\"), datetime(2024, 1, 1), \"Initial investment\", \"investment\"),\n...     CashFlowItem(Money(\"-1100\"), datetime(2024, 12, 31), \"Return\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Calculate PV with 5% discount rate\n&gt;&gt;&gt; pv = present_value(cf, InterestRate(\"5% annual\"))\n&gt;&gt;&gt; print(f\"Present Value: {pv}\")  # Should be close to zero for 10% return vs 5% discount\n</code></pre>"},{"location":"modules/#money_warp.present_value.present_value_of_annuity","title":"<code>present_value_of_annuity(payment_amount, interest_rate, periods, payment_timing='end')</code>","text":"<p>Calculate the Present Value of an ordinary annuity or annuity due.</p> <p>An annuity is a series of equal payments made at regular intervals.</p> <p>Formula for ordinary annuity (payments at end of period): PV = PMT x [(1 - (1 + r)^(-n)) / r]</p> <p>Formula for annuity due (payments at beginning of period): PV = PMT x [(1 - (1 + r)^(-n)) / r] x (1 + r)</p> <p>Parameters:</p> Name Type Description Default <code>payment_amount</code> <code>Money</code> <p>The amount of each payment</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <code>periods</code> <code>int</code> <p>The number of payment periods</p> required <code>payment_timing</code> <code>str</code> <p>\"end\" for ordinary annuity, \"begin\" for annuity due</p> <code>'end'</code> <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the annuity</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Money, InterestRate, present_value_of_annuity\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PV of $1000 monthly payments for 12 months at 5% annual\n&gt;&gt;&gt; monthly_rate = InterestRate(\"5% annual\").to_monthly()\n&gt;&gt;&gt; pv = present_value_of_annuity(Money(\"1000\"), monthly_rate, 12)\n&gt;&gt;&gt; print(f\"PV of annuity: {pv}\")\n</code></pre>"},{"location":"modules/#money_warp.present_value.present_value_of_perpetuity","title":"<code>present_value_of_perpetuity(payment_amount, interest_rate)</code>","text":"<p>Calculate the Present Value of a perpetuity.</p> <p>A perpetuity is a series of equal payments that continue forever.</p> <p>Formula: PV = PMT / r</p> <p>Parameters:</p> Name Type Description Default <code>payment_amount</code> <code>Money</code> <p>The amount of each payment</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the perpetuity</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If interest rate is zero or negative</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Money, InterestRate, present_value_of_perpetuity\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PV of $100 annual payments forever at 5%\n&gt;&gt;&gt; pv = present_value_of_perpetuity(Money(\"100\"), InterestRate(\"5% annual\"))\n&gt;&gt;&gt; print(f\"PV of perpetuity: {pv}\")  # Should be $2000\n</code></pre>"},{"location":"modules/#money_warp.present_value.discount_factor","title":"<code>discount_factor(interest_rate, periods)</code>","text":"<p>Calculate the discount factor for a given interest rate and time periods.</p> <p>Formula: DF = 1 / (1 + r)^n</p> <p>Parameters:</p> Name Type Description Default <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <code>periods</code> <code>Union[int, Decimal]</code> <p>The number of periods (can be fractional)</p> required <p>Returns:</p> Type Description <code>Decimal</code> <p>The discount factor as a Decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import InterestRate, discount_factor\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discount factor for 5% over 2 years\n&gt;&gt;&gt; df = discount_factor(InterestRate(\"5% annual\"), 2)\n&gt;&gt;&gt; print(f\"Discount factor: {df}\")  # Should be about 0.907\n</code></pre>"},{"location":"modules/#money_warp.present_value.internal_rate_of_return","title":"<code>internal_rate_of_return(cash_flow, guess=None, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Internal Rate of Return (IRR) of a cash flow stream.</p> <p>The IRR is the discount rate that makes the Net Present Value (NPV) equal to zero. It represents the effective annual rate of return of the investment.</p> <p>Uses scipy.optimize.fsolve for robust numerical solution.</p> <p>Note: To calculate IRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     irr = warped_loan.irr()</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>guess</code> <code>Optional[InterestRate]</code> <p>Initial guess for IRR (defaults to 10% annual)</p> <code>None</code> <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The internal rate of return as an InterestRate</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If IRR cannot be found (no solution or doesn't converge)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, internal_rate_of_return\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simple investment: -$1000 now, +$1100 in 1 year\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n...     CashFlowItem(Money(\"1100\"), datetime(2024, 12, 31), \"Return\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; irr = internal_rate_of_return(cf)\n&gt;&gt;&gt; print(f\"IRR: {irr}\")  # Should be approximately 10%\n</code></pre>"},{"location":"modules/#money_warp.present_value.irr","title":"<code>irr(cash_flow, guess=None, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Internal Rate of Return (IRR) of a cash flow stream.</p> <p>This is a convenience function that calls internal_rate_of_return() with default parameters for most common use cases.</p> <p>Note: To calculate IRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     irr = warped_loan.irr()</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>guess</code> <code>Optional[InterestRate]</code> <p>Initial guess for IRR (defaults to 10% annual)</p> <code>None</code> <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The internal rate of return as an InterestRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, irr\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Investment analysis\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-5000\"), datetime(2024, 1, 1), \"Initial investment\", \"investment\"),\n...     CashFlowItem(Money(\"1500\"), datetime(2024, 6, 1), \"Return 1\", \"return\"),\n...     CashFlowItem(Money(\"2000\"), datetime(2024, 12, 1), \"Return 2\", \"return\"),\n...     CashFlowItem(Money(\"2500\"), datetime(2025, 6, 1), \"Final return\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; investment_irr = irr(cf)\n&gt;&gt;&gt; print(f\"Investment IRR: {investment_irr}\")\n</code></pre>"},{"location":"modules/#money_warp.present_value.modified_internal_rate_of_return","title":"<code>modified_internal_rate_of_return(cash_flow, finance_rate, reinvestment_rate, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Modified Internal Rate of Return (MIRR).</p> <p>MIRR addresses some limitations of IRR by using different rates for financing negative cash flows and reinvesting positive cash flows.</p> <p>Formula: MIRR = (FV of positive flows / PV of negative flows)^(1/n) - 1</p> <p>Note: To calculate MIRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     mirr = modified_internal_rate_of_return(warped_loan.generate_expected_cash_flow(), ...)</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>finance_rate</code> <code>InterestRate</code> <p>Rate for financing negative cash flows</p> required <code>reinvestment_rate</code> <code>InterestRate</code> <p>Rate for reinvesting positive cash flows</p> required <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The modified internal rate of return as an InterestRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, InterestRate, modified_internal_rate_of_return\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Investment with different financing and reinvestment rates\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n...     CashFlowItem(Money(\"300\"), datetime(2024, 6, 1), \"Return 1\", \"return\"),\n...     CashFlowItem(Money(\"400\"), datetime(2024, 12, 1), \"Return 2\", \"return\"),\n...     CashFlowItem(Money(\"500\"), datetime(2025, 6, 1), \"Return 3\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; mirr = modified_internal_rate_of_return(\n...     cf,\n...     InterestRate(\"8% annual\"),  # Financing rate\n...     InterestRate(\"6% annual\")   # Reinvestment rate\n... )\n&gt;&gt;&gt; print(f\"MIRR: {mirr}\")\n</code></pre>"},{"location":"modules/#present_value_of_annuity","title":"present_value_of_annuity","text":""},{"location":"modules/#money_warp.present_value_of_annuity","title":"<code>money_warp.present_value_of_annuity(payment_amount, interest_rate, periods, payment_timing='end')</code>","text":"<p>Calculate the Present Value of an ordinary annuity or annuity due.</p> <p>An annuity is a series of equal payments made at regular intervals.</p> <p>Formula for ordinary annuity (payments at end of period): PV = PMT x [(1 - (1 + r)^(-n)) / r]</p> <p>Formula for annuity due (payments at beginning of period): PV = PMT x [(1 - (1 + r)^(-n)) / r] x (1 + r)</p> <p>Parameters:</p> Name Type Description Default <code>payment_amount</code> <code>Money</code> <p>The amount of each payment</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <code>periods</code> <code>int</code> <p>The number of payment periods</p> required <code>payment_timing</code> <code>str</code> <p>\"end\" for ordinary annuity, \"begin\" for annuity due</p> <code>'end'</code> <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the annuity</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Money, InterestRate, present_value_of_annuity\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PV of $1000 monthly payments for 12 months at 5% annual\n&gt;&gt;&gt; monthly_rate = InterestRate(\"5% annual\").to_monthly()\n&gt;&gt;&gt; pv = present_value_of_annuity(Money(\"1000\"), monthly_rate, 12)\n&gt;&gt;&gt; print(f\"PV of annuity: {pv}\")\n</code></pre>"},{"location":"modules/#present_value_of_perpetuity","title":"present_value_of_perpetuity","text":""},{"location":"modules/#money_warp.present_value_of_perpetuity","title":"<code>money_warp.present_value_of_perpetuity(payment_amount, interest_rate)</code>","text":"<p>Calculate the Present Value of a perpetuity.</p> <p>A perpetuity is a series of equal payments that continue forever.</p> <p>Formula: PV = PMT / r</p> <p>Parameters:</p> Name Type Description Default <code>payment_amount</code> <code>Money</code> <p>The amount of each payment</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <p>Returns:</p> Type Description <code>Money</code> <p>The present value of the perpetuity</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If interest rate is zero or negative</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import Money, InterestRate, present_value_of_perpetuity\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PV of $100 annual payments forever at 5%\n&gt;&gt;&gt; pv = present_value_of_perpetuity(Money(\"100\"), InterestRate(\"5% annual\"))\n&gt;&gt;&gt; print(f\"PV of perpetuity: {pv}\")  # Should be $2000\n</code></pre>"},{"location":"modules/#discount_factor","title":"discount_factor","text":""},{"location":"modules/#money_warp.discount_factor","title":"<code>money_warp.discount_factor(interest_rate, periods)</code>","text":"<p>Calculate the discount factor for a given interest rate and time periods.</p> <p>Formula: DF = 1 / (1 + r)^n</p> <p>Parameters:</p> Name Type Description Default <code>interest_rate</code> <code>InterestRate</code> <p>The interest rate per period</p> required <code>periods</code> <code>Union[int, Decimal]</code> <p>The number of periods (can be fractional)</p> required <p>Returns:</p> Type Description <code>Decimal</code> <p>The discount factor as a Decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from money_warp import InterestRate, discount_factor\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discount factor for 5% over 2 years\n&gt;&gt;&gt; df = discount_factor(InterestRate(\"5% annual\"), 2)\n&gt;&gt;&gt; print(f\"Discount factor: {df}\")  # Should be about 0.907\n</code></pre>"},{"location":"modules/#irr-functions","title":"IRR Functions","text":""},{"location":"modules/#internal_rate_of_return","title":"internal_rate_of_return","text":""},{"location":"modules/#money_warp.internal_rate_of_return","title":"<code>money_warp.internal_rate_of_return(cash_flow, guess=None, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Internal Rate of Return (IRR) of a cash flow stream.</p> <p>The IRR is the discount rate that makes the Net Present Value (NPV) equal to zero. It represents the effective annual rate of return of the investment.</p> <p>Uses scipy.optimize.fsolve for robust numerical solution.</p> <p>Note: To calculate IRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     irr = warped_loan.irr()</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>guess</code> <code>Optional[InterestRate]</code> <p>Initial guess for IRR (defaults to 10% annual)</p> <code>None</code> <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The internal rate of return as an InterestRate</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If IRR cannot be found (no solution or doesn't converge)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, internal_rate_of_return\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simple investment: -$1000 now, +$1100 in 1 year\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n...     CashFlowItem(Money(\"1100\"), datetime(2024, 12, 31), \"Return\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; irr = internal_rate_of_return(cf)\n&gt;&gt;&gt; print(f\"IRR: {irr}\")  # Should be approximately 10%\n</code></pre>"},{"location":"modules/#irr","title":"irr","text":""},{"location":"modules/#money_warp.irr","title":"<code>money_warp.irr(cash_flow, guess=None, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Internal Rate of Return (IRR) of a cash flow stream.</p> <p>This is a convenience function that calls internal_rate_of_return() with default parameters for most common use cases.</p> <p>Note: To calculate IRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     irr = warped_loan.irr()</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>guess</code> <code>Optional[InterestRate]</code> <p>Initial guess for IRR (defaults to 10% annual)</p> <code>None</code> <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The internal rate of return as an InterestRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, irr\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Investment analysis\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-5000\"), datetime(2024, 1, 1), \"Initial investment\", \"investment\"),\n...     CashFlowItem(Money(\"1500\"), datetime(2024, 6, 1), \"Return 1\", \"return\"),\n...     CashFlowItem(Money(\"2000\"), datetime(2024, 12, 1), \"Return 2\", \"return\"),\n...     CashFlowItem(Money(\"2500\"), datetime(2025, 6, 1), \"Final return\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; investment_irr = irr(cf)\n&gt;&gt;&gt; print(f\"Investment IRR: {investment_irr}\")\n</code></pre>"},{"location":"modules/#modified_internal_rate_of_return","title":"modified_internal_rate_of_return","text":""},{"location":"modules/#money_warp.modified_internal_rate_of_return","title":"<code>money_warp.modified_internal_rate_of_return(cash_flow, finance_rate, reinvestment_rate, year_size=YearSize.commercial)</code>","text":"<p>Calculate the Modified Internal Rate of Return (MIRR).</p> <p>MIRR addresses some limitations of IRR by using different rates for financing negative cash flows and reinvesting positive cash flows.</p> <p>Formula: MIRR = (FV of positive flows / PV of negative flows)^(1/n) - 1</p> <p>Note: To calculate MIRR from a specific date, use the Time Machine: with Warp(loan, target_date) as warped_loan:     mirr = modified_internal_rate_of_return(warped_loan.generate_expected_cash_flow(), ...)</p> <p>Parameters:</p> Name Type Description Default <code>cash_flow</code> <code>CashFlow</code> <p>The cash flow stream to analyze</p> required <code>finance_rate</code> <code>InterestRate</code> <p>Rate for financing negative cash flows</p> required <code>reinvestment_rate</code> <code>InterestRate</code> <p>Rate for reinvesting positive cash flows</p> required <code>year_size</code> <code>YearSize</code> <p>Day-count convention (YearSize.commercial for 365 days,        YearSize.banker for 360 days)</p> <code>commercial</code> <p>Returns:</p> Type Description <code>InterestRate</code> <p>The modified internal rate of return as an InterestRate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from money_warp import CashFlow, CashFlowItem, Money, InterestRate, modified_internal_rate_of_return\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Investment with different financing and reinvestment rates\n&gt;&gt;&gt; items = [\n...     CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n...     CashFlowItem(Money(\"300\"), datetime(2024, 6, 1), \"Return 1\", \"return\"),\n...     CashFlowItem(Money(\"400\"), datetime(2024, 12, 1), \"Return 2\", \"return\"),\n...     CashFlowItem(Money(\"500\"), datetime(2025, 6, 1), \"Return 3\", \"return\"),\n... ]\n&gt;&gt;&gt; cf = CashFlow(items)\n&gt;&gt;&gt;\n&gt;&gt;&gt; mirr = modified_internal_rate_of_return(\n...     cf,\n...     InterestRate(\"8% annual\"),  # Financing rate\n...     InterestRate(\"6% annual\")   # Reinvestment rate\n... )\n&gt;&gt;&gt; print(f\"MIRR: {mirr}\")\n</code></pre>"},{"location":"modules/#date-generation-utilities","title":"Date Generation Utilities","text":""},{"location":"modules/#generate_monthly_dates","title":"generate_monthly_dates","text":""},{"location":"modules/#money_warp.generate_monthly_dates","title":"<code>money_warp.generate_monthly_dates(start_date, num_payments)</code>","text":"<p>Generate a list of monthly payment due dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of monthly payments to generate</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing monthly due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_monthly_dates(datetime(2024, 1, 15), 3)\n&gt;&gt;&gt; # Returns [2024-01-15, 2024-02-15, 2024-03-15]\n</code></pre>"},{"location":"modules/#generate_biweekly_dates","title":"generate_biweekly_dates","text":""},{"location":"modules/#money_warp.generate_biweekly_dates","title":"<code>money_warp.generate_biweekly_dates(start_date, num_payments)</code>","text":"<p>Generate a list of bi-weekly (every 14 days) payment due dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of bi-weekly payments to generate</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing bi-weekly due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_biweekly_dates(datetime(2024, 1, 1), 4)\n&gt;&gt;&gt; # Returns [2024-01-01, 2024-01-15, 2024-01-29, 2024-02-12]\n</code></pre>"},{"location":"modules/#generate_weekly_dates","title":"generate_weekly_dates","text":""},{"location":"modules/#money_warp.generate_weekly_dates","title":"<code>money_warp.generate_weekly_dates(start_date, num_payments)</code>","text":"<p>Generate a list of weekly payment due dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of weekly payments to generate</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing weekly due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_weekly_dates(datetime(2024, 1, 1), 4)\n&gt;&gt;&gt; # Returns [2024-01-01, 2024-01-08, 2024-01-15, 2024-01-22]\n</code></pre>"},{"location":"modules/#generate_quarterly_dates","title":"generate_quarterly_dates","text":""},{"location":"modules/#money_warp.generate_quarterly_dates","title":"<code>money_warp.generate_quarterly_dates(start_date, num_payments)</code>","text":"<p>Generate a list of quarterly payment due dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of quarterly payments to generate</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing quarterly due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_quarterly_dates(datetime(2024, 1, 15), 4)\n&gt;&gt;&gt; # Returns [2024-01-15, 2024-04-15, 2024-07-15, 2024-10-15]\n</code></pre>"},{"location":"modules/#generate_annual_dates","title":"generate_annual_dates","text":""},{"location":"modules/#money_warp.generate_annual_dates","title":"<code>money_warp.generate_annual_dates(start_date, num_payments)</code>","text":"<p>Generate a list of annual payment due dates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of annual payments to generate</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing annual due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_annual_dates(datetime(2024, 1, 15), 3)\n&gt;&gt;&gt; # Returns [2024-01-15, 2025-01-15, 2026-01-15]\n</code></pre>"},{"location":"modules/#generate_custom_interval_dates","title":"generate_custom_interval_dates","text":""},{"location":"modules/#money_warp.generate_custom_interval_dates","title":"<code>money_warp.generate_custom_interval_dates(start_date, num_payments, interval_days)</code>","text":"<p>Generate a list of payment due dates with custom day intervals.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>datetime</code> <p>The starting date (first payment date)</p> required <code>num_payments</code> <code>int</code> <p>Number of payments to generate</p> required <code>interval_days</code> <code>int</code> <p>Number of days between payments</p> required <p>Returns:</p> Type Description <code>List[datetime]</code> <p>List of datetime objects representing due dates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dates = generate_custom_interval_dates(datetime(2024, 1, 1), 4, 10)\n&gt;&gt;&gt; # Returns payments every 10 days: [2024-01-01, 2024-01-11, 2024-01-21, 2024-01-31]\n</code></pre>"},{"location":"modules/#tax-classes","title":"Tax Classes","text":""},{"location":"modules/#basetax","title":"BaseTax","text":""},{"location":"modules/#money_warp.BaseTax","title":"<code>money_warp.BaseTax</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all loan taxes.</p> <p>All taxes should inherit from this and implement the calculate method. The interface mirrors BaseScheduler: simple, one method, receives what it needs.</p>"},{"location":"modules/#money_warp.BaseTax-functions","title":"Functions","text":""},{"location":"modules/#money_warp.BaseTax.calculate","title":"<code>calculate(schedule, disbursement_date)</code>  <code>abstractmethod</code>","text":"<p>Calculate tax based on the amortization schedule.</p> <p>Parameters:</p> Name Type Description Default <code>schedule</code> <code>PaymentSchedule</code> <p>The loan's payment schedule with principal breakdown per installment.</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan was disbursed.</p> required <p>Returns:</p> Type Description <code>TaxResult</code> <p>TaxResult with total tax and per-installment breakdown.</p>"},{"location":"modules/#iof","title":"IOF","text":""},{"location":"modules/#money_warp.IOF","title":"<code>money_warp.IOF</code>","text":"<p>               Bases: <code>BaseTax</code></p> <p>Brazilian IOF tax on loan operations.</p> <p>IOF has two components applied to each installment's principal payment: - Daily rate: applied per day from disbursement to payment date (capped at max_daily_days) - Additional rate: flat percentage applied once per installment</p> <p>Parameters:</p> Name Type Description Default <code>daily_rate</code> <code>Union[str, Decimal]</code> <p>Daily IOF rate as decimal or string (e.g., Decimal(\"0.000082\") or \"0.0082%\")</p> required <code>additional_rate</code> <code>Union[str, Decimal]</code> <p>Additional flat IOF rate as decimal or string (e.g., Decimal(\"0.0038\") or \"0.38%\")</p> required <code>max_daily_days</code> <code>int</code> <p>Maximum number of days for daily rate calculation (default 365)</p> <code>365</code> <code>rounding</code> <code>IOFRounding</code> <p>Rounding strategy for component aggregation (default PRECISE)</p> <code>PRECISE</code>"},{"location":"modules/#money_warp.IOF-attributes","title":"Attributes","text":""},{"location":"modules/#money_warp.IOF.daily_rate","title":"<code>daily_rate</code>  <code>property</code>","text":"<p>The daily IOF rate as a decimal.</p>"},{"location":"modules/#money_warp.IOF.additional_rate","title":"<code>additional_rate</code>  <code>property</code>","text":"<p>The additional flat IOF rate as a decimal.</p>"},{"location":"modules/#money_warp.IOF.max_daily_days","title":"<code>max_daily_days</code>  <code>property</code>","text":"<p>Maximum days for daily rate calculation.</p>"},{"location":"modules/#money_warp.IOF.rounding","title":"<code>rounding</code>  <code>property</code>","text":"<p>The rounding strategy used for component aggregation.</p>"},{"location":"modules/#money_warp.IOF-functions","title":"Functions","text":""},{"location":"modules/#money_warp.IOF.calculate","title":"<code>calculate(schedule, disbursement_date)</code>","text":"<p>Calculate IOF for each installment in the schedule.</p> For each installment <p>days = min(days_from_disbursement_to_due_date, max_daily_days) daily_iof = principal_payment * daily_rate * days additional_iof = principal_payment * additional_rate installment_tax = daily_iof + additional_iof</p>"},{"location":"modules/#individualiof","title":"IndividualIOF","text":""},{"location":"modules/#money_warp.IndividualIOF","title":"<code>money_warp.IndividualIOF</code>","text":"<p>               Bases: <code>IOF</code></p> <p>IOF for Pessoa Fisica (PF) -- individual/natural person borrowers.</p> <p>Pre-configured with the standard PF rates: - Daily rate: 0.0082% (0.000082) - Additional rate: 0.38% (0.0038)</p> <p>All parameters can be overridden if the rates change by regulation.</p>"},{"location":"modules/#corporateiof","title":"CorporateIOF","text":""},{"location":"modules/#money_warp.CorporateIOF","title":"<code>money_warp.CorporateIOF</code>","text":"<p>               Bases: <code>IOF</code></p> <p>IOF for Pessoa Juridica (PJ) -- legal entity/company borrowers.</p> <p>Pre-configured with the standard PJ rates: - Daily rate: 0.0041% (0.000041) - Additional rate: 0.38% (0.0038)</p> <p>All parameters can be overridden if the rates change by regulation.</p>"},{"location":"modules/#iofrounding","title":"IOFRounding","text":""},{"location":"modules/#money_warp.IOFRounding","title":"<code>money_warp.IOFRounding</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Rounding strategy for IOF component aggregation.</p> sum high-precision daily and additional components, round once <p>per installment.  This is the mathematically purer approach.</p> <p>PER_COMPONENT: round each component (daily, additional) to 2 decimal     places before summing.  Matches the behavior of common Brazilian     lending platforms.</p>"},{"location":"modules/#taxresult","title":"TaxResult","text":""},{"location":"modules/#money_warp.TaxResult","title":"<code>money_warp.TaxResult</code>  <code>dataclass</code>","text":"<p>Result of a tax calculation across an entire schedule.</p>"},{"location":"modules/#taxinstallmentdetail","title":"TaxInstallmentDetail","text":""},{"location":"modules/#money_warp.TaxInstallmentDetail","title":"<code>money_warp.TaxInstallmentDetail</code>  <code>dataclass</code>","text":"<p>Tax breakdown for a single installment.</p>"},{"location":"modules/#timezone-functions","title":"Timezone Functions","text":""},{"location":"modules/#get_tz","title":"get_tz","text":""},{"location":"modules/#money_warp.get_tz","title":"<code>money_warp.get_tz()</code>","text":"<p>Return the current default timezone.</p>"},{"location":"modules/#set_tz","title":"set_tz","text":""},{"location":"modules/#money_warp.set_tz","title":"<code>money_warp.set_tz(tz)</code>","text":"<p>Set the default timezone.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>Union[str, tzinfo]</code> <p>A timezone name (e.g. <code>\"America/Sao_Paulo\"</code>) or a <code>tzinfo</code> instance.</p> required"},{"location":"modules/#now","title":"now","text":""},{"location":"modules/#money_warp.now","title":"<code>money_warp.now()</code>","text":"<p>Return the current time in the configured timezone (always aware).</p>"},{"location":"modules/#ensure_aware","title":"ensure_aware","text":""},{"location":"modules/#money_warp.ensure_aware","title":"<code>money_warp.ensure_aware(dt)</code>","text":"<p>Guarantee that dt is timezone-aware.</p> <p>If dt is naive, the configured default timezone is attached. If dt is already aware, it is returned unchanged.</p>"},{"location":"modules/#tz_aware","title":"tz_aware","text":""},{"location":"modules/#money_warp.tz_aware","title":"<code>money_warp.tz_aware(func)</code>","text":"<p>Decorator that makes every <code>datetime</code> argument timezone-aware.</p> <p>At call time each positional and keyword argument is inspected:</p> <ul> <li><code>datetime</code> values are passed through :func:<code>ensure_aware</code>.</li> <li><code>list</code> values whose first element is a <code>datetime</code> are coerced   element-wise.</li> <li>Everything else is left untouched.</li> </ul>"},{"location":"modules/#grossup-functions","title":"Grossup Functions","text":""},{"location":"modules/#grossup","title":"grossup","text":""},{"location":"modules/#money_warp.grossup","title":"<code>money_warp.grossup</code>","text":"<p>Grossup calculation using scipy.optimize.brentq bracketed root-finding.</p>"},{"location":"modules/#money_warp.grossup-classes","title":"Classes","text":""},{"location":"modules/#money_warp.grossup.GrossupResult","title":"<code>GrossupResult</code>","text":"<p>Result of a grossup calculation.</p> <p>Carries the grossed-up principal, the original requested amount, the computed tax, and all the parameters needed to construct a Loan via the convenience method <code>to_loan()</code>.</p> <p>Attributes:</p> Name Type Description <code>principal</code> <p>The grossed-up principal (loan amount including financed tax).</p> <code>requested_amount</code> <p>The amount the borrower actually receives.</p> <code>total_tax</code> <p>Total tax computed on the grossed-up principal.</p> Functions\u00b6 <code>to_loan(**loan_kwargs)</code> \u00b6 <p>Create a Loan from this grossup result.</p> <p>All schedule parameters (principal, interest_rate, due_dates, disbursement_date, scheduler, taxes) are forwarded automatically. Pass any additional Loan keyword arguments (fine_rate, grace_period_days, mora_interest_rate, mora_strategy) via <code>loan_kwargs</code>.</p> <p>Returns:</p> Type Description <code>Loan</code> <p>A fully configured Loan with the grossed-up principal.</p>"},{"location":"modules/#money_warp.grossup-functions","title":"Functions","text":""},{"location":"modules/#money_warp.grossup.grossup","title":"<code>grossup(requested_amount, interest_rate, due_dates, disbursement_date, scheduler, taxes)</code>","text":"<p>Compute the grossed-up principal so that principal - total_tax = requested_amount.</p> <p>The borrower wants to receive <code>requested_amount</code>. Taxes are calculated on the loan principal, which must be larger to compensate. Uses <code>scipy.optimize.brentq</code> (bracketed bisection) to find the root of <code>f(p) = p - requested_amount - tax(p) = 0</code>.</p> <p><code>brentq</code> is preferred over <code>fsolve</code> because the objective function has a staircase shape (cent-level rounding in schedule/tax computation makes it non-smooth), which can cause <code>fsolve</code>'s numerical Jacobian to stall.</p> <p>Parameters:</p> Name Type Description Default <code>requested_amount</code> <code>Money</code> <p>The net amount the borrower wants to receive.</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The loan interest rate.</p> required <code>due_dates</code> <code>list[datetime]</code> <p>Payment due dates.</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan is disbursed.</p> required <code>scheduler</code> <code>type[BaseScheduler]</code> <p>Scheduler class for generating the amortization schedule.</p> required <code>taxes</code> <code>list[BaseTax]</code> <p>List of taxes to finance into the principal.</p> required <p>Returns:</p> Type Description <code>GrossupResult</code> <p>GrossupResult with the grossed-up principal, tax breakdown, and a</p> <code>GrossupResult</code> <p><code>to_loan()</code> convenience method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If requested_amount is not positive, no taxes provided,         or the solver fails to converge.</p>"},{"location":"modules/#money_warp.grossup.grossup_loan","title":"<code>grossup_loan(requested_amount, interest_rate, due_dates, disbursement_date, scheduler, taxes, **loan_kwargs)</code>","text":"<p>Compute a grossed-up loan in a single call.</p> <p>Sugar for <code>grossup(...).to_loan(**loan_kwargs)</code>. The borrower wants to receive <code>requested_amount</code>; this function finds the principal that satisfies <code>principal - tax = requested_amount</code> and returns a fully configured Loan.</p> <p>Parameters:</p> Name Type Description Default <code>requested_amount</code> <code>Money</code> <p>The net amount the borrower wants to receive.</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The loan interest rate.</p> required <code>due_dates</code> <code>list[datetime]</code> <p>Payment due dates.</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan is disbursed.</p> required <code>scheduler</code> <code>type[BaseScheduler]</code> <p>Scheduler class for generating the amortization schedule.</p> required <code>taxes</code> <code>list[BaseTax]</code> <p>List of taxes to finance into the principal.</p> required <code>**loan_kwargs</code> <code>Any</code> <p>Extra keyword arguments forwarded to the Loan constructor (e.g. fine_rate, grace_period_days, mora_interest_rate, mora_strategy).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Loan</code> <p>A Loan with the grossed-up principal and taxes attached.</p>"},{"location":"modules/#grossup_loan","title":"grossup_loan","text":""},{"location":"modules/#money_warp.grossup_loan","title":"<code>money_warp.grossup_loan(requested_amount, interest_rate, due_dates, disbursement_date, scheduler, taxes, **loan_kwargs)</code>","text":"<p>Compute a grossed-up loan in a single call.</p> <p>Sugar for <code>grossup(...).to_loan(**loan_kwargs)</code>. The borrower wants to receive <code>requested_amount</code>; this function finds the principal that satisfies <code>principal - tax = requested_amount</code> and returns a fully configured Loan.</p> <p>Parameters:</p> Name Type Description Default <code>requested_amount</code> <code>Money</code> <p>The net amount the borrower wants to receive.</p> required <code>interest_rate</code> <code>InterestRate</code> <p>The loan interest rate.</p> required <code>due_dates</code> <code>list[datetime]</code> <p>Payment due dates.</p> required <code>disbursement_date</code> <code>datetime</code> <p>When the loan is disbursed.</p> required <code>scheduler</code> <code>type[BaseScheduler]</code> <p>Scheduler class for generating the amortization schedule.</p> required <code>taxes</code> <code>list[BaseTax]</code> <p>List of taxes to finance into the principal.</p> required <code>**loan_kwargs</code> <code>Any</code> <p>Extra keyword arguments forwarded to the Loan constructor (e.g. fine_rate, grace_period_days, mora_interest_rate, mora_strategy).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Loan</code> <p>A Loan with the grossed-up principal and taxes attached.</p>"},{"location":"modules/#grossupresult","title":"GrossupResult","text":""},{"location":"modules/#money_warp.GrossupResult","title":"<code>money_warp.GrossupResult</code>","text":"<p>Result of a grossup calculation.</p> <p>Carries the grossed-up principal, the original requested amount, the computed tax, and all the parameters needed to construct a Loan via the convenience method <code>to_loan()</code>.</p> <p>Attributes:</p> Name Type Description <code>principal</code> <p>The grossed-up principal (loan amount including financed tax).</p> <code>requested_amount</code> <p>The amount the borrower actually receives.</p> <code>total_tax</code> <p>Total tax computed on the grossed-up principal.</p>"},{"location":"modules/#money_warp.GrossupResult-functions","title":"Functions","text":""},{"location":"modules/#money_warp.GrossupResult.to_loan","title":"<code>to_loan(**loan_kwargs)</code>","text":"<p>Create a Loan from this grossup result.</p> <p>All schedule parameters (principal, interest_rate, due_dates, disbursement_date, scheduler, taxes) are forwarded automatically. Pass any additional Loan keyword arguments (fine_rate, grace_period_days, mora_interest_rate, mora_strategy) via <code>loan_kwargs</code>.</p> <p>Returns:</p> Type Description <code>Loan</code> <p>A fully configured Loan with the grossed-up principal.</p>"},{"location":"examples/cash_flow/","title":"Cash Flow Analysis","text":"<p>MoneyWarp treats all financial activities as cash flows through time. The <code>CashFlow</code> and <code>CashFlowItem</code> classes provide powerful tools for modeling, analyzing, and querying financial transactions.</p>"},{"location":"examples/cash_flow/#basic-cash-flow-concepts","title":"Basic Cash Flow Concepts","text":"<p>A cash flow is a collection of monetary movements over time:</p> <pre><code>from datetime import datetime\nfrom money_warp import CashFlow, CashFlowItem, Money\n\n# Create individual transactions\ntransactions = [\n    CashFlowItem(Money(\"1000.00\"), datetime(2024, 1, 1), \"Initial deposit\", \"deposit\"),\n    CashFlowItem(Money(\"-50.00\"), datetime(2024, 1, 15), \"Monthly fee\", \"fee\"),\n    CashFlowItem(Money(\"25.00\"), datetime(2024, 2, 1), \"Interest earned\", \"interest\"),\n    CashFlowItem(Money(\"-200.00\"), datetime(2024, 2, 15), \"Withdrawal\", \"withdrawal\"),\n    CashFlowItem(Money(\"30.00\"), datetime(2024, 3, 1), \"Interest earned\", \"interest\"),\n]\n\n# Create cash flow\ncash_flow = CashFlow(transactions)\n\nprint(f\"Total transactions: {len(cash_flow)}\")\nprint(f\"Net cash flow: {cash_flow.sum()}\")\nprint(f\"Date range: {cash_flow.start_date()} to {cash_flow.end_date()}\")\n</code></pre> <p>Output: <pre><code>Total transactions: 5\nNet cash flow: 805.00\nDate range: 2024-01-01 00:00:00 to 2024-03-01 00:00:00\n</code></pre></p>"},{"location":"examples/cash_flow/#cashflowitem-details","title":"CashFlowItem Details","text":"<p>Each transaction captures essential information:</p> <pre><code># Create a detailed transaction\ntransaction = CashFlowItem(\n    amount=Money(\"-1250.00\"),\n    datetime=datetime(2024, 6, 15, 14, 30),  # Specific time\n    description=\"Rent payment for June\",\n    category=\"housing\"\n)\n\nprint(f\"Amount: {transaction.amount}\")\nprint(f\"Date/Time: {transaction.datetime}\")\nprint(f\"Description: {transaction.description}\")\nprint(f\"Category: {transaction.category}\")\nprint(f\"Is outflow? {transaction.is_outflow()}\")\nprint(f\"Is inflow? {transaction.is_inflow()}\")\n\n# String representation\nprint(f\"Transaction: {transaction}\")\n</code></pre> <p>Output: <pre><code>Amount: -1,250.00\nDate/Time: 2024-06-15 14:30:00\nDescription: Rent payment for June\nCategory: housing\nIs outflow? True\nIs inflow? False\nTransaction: -1,250.00 on 2024-06-15 14:30:00: Rent payment for June (housing)\n</code></pre></p>"},{"location":"examples/cash_flow/#powerful-querying-with-cashflowquery","title":"Powerful Querying with CashFlowQuery","text":"<p>MoneyWarp provides SQLAlchemy-style querying for cash flows:</p> <pre><code># Sample data: Personal finance for 3 months\npersonal_transactions = [\n    # January\n    CashFlowItem(Money(\"5000.00\"), datetime(2024, 1, 1), \"Salary\", \"income\"),\n    CashFlowItem(Money(\"-1200.00\"), datetime(2024, 1, 1), \"Rent\", \"housing\"),\n    CashFlowItem(Money(\"-300.00\"), datetime(2024, 1, 5), \"Groceries\", \"food\"),\n    CashFlowItem(Money(\"-150.00\"), datetime(2024, 1, 10), \"Utilities\", \"utilities\"),\n    CashFlowItem(Money(\"-80.00\"), datetime(2024, 1, 15), \"Gas\", \"transportation\"),\n\n    # February  \n    CashFlowItem(Money(\"5000.00\"), datetime(2024, 2, 1), \"Salary\", \"income\"),\n    CashFlowItem(Money(\"-1200.00\"), datetime(2024, 2, 1), \"Rent\", \"housing\"),\n    CashFlowItem(Money(\"-280.00\"), datetime(2024, 2, 8), \"Groceries\", \"food\"),\n    CashFlowItem(Money(\"-120.00\"), datetime(2024, 2, 12), \"Utilities\", \"utilities\"),\n    CashFlowItem(Money(\"-90.00\"), datetime(2024, 2, 18), \"Gas\", \"transportation\"),\n    CashFlowItem(Money(\"-500.00\"), datetime(2024, 2, 20), \"Car repair\", \"transportation\"),\n\n    # March\n    CashFlowItem(Money(\"5000.00\"), datetime(2024, 3, 1), \"Salary\", \"income\"),\n    CashFlowItem(Money(\"-1200.00\"), datetime(2024, 3, 1), \"Rent\", \"housing\"),\n    CashFlowItem(Money(\"-320.00\"), datetime(2024, 3, 7), \"Groceries\", \"food\"),\n    CashFlowItem(Money(\"-140.00\"), datetime(2024, 3, 11), \"Utilities\", \"utilities\"),\n    CashFlowItem(Money(\"-75.00\"), datetime(2024, 3, 16), \"Gas\", \"transportation\"),\n]\n\npersonal_cf = CashFlow(personal_transactions)\n\n# Query by category\nincome = personal_cf.query.filter_by(category=\"income\")\nhousing = personal_cf.query.filter_by(category=\"housing\") \nfood = personal_cf.query.filter_by(category=\"food\")\n\nprint(\"Spending by Category:\")\nprint(f\"Income: {income.sum()}\")\nprint(f\"Housing: {housing.sum()}\")\nprint(f\"Food: {food.sum()}\")\nprint(f\"Transportation: {personal_cf.query.filter_by(category='transportation').sum()}\")\nprint(f\"Utilities: {personal_cf.query.filter_by(category='utilities').sum()}\")\n</code></pre> <p>Output: <pre><code>Spending by Category:\nIncome: 15,000.00\nHousing: -3,600.00\nFood: -900.00\nTransportation: -745.00\nUtilities: -410.00\n</code></pre></p>"},{"location":"examples/cash_flow/#date-based-filtering","title":"Date-Based Filtering","text":"<p>Query cash flows by date ranges:</p> <pre><code># Filter by specific month\nfebruary = personal_cf.query.filter_by(\n    datetime__gte=datetime(2024, 2, 1),\n    datetime__lt=datetime(2024, 3, 1)\n)\n\nprint(f\"February transactions: {len(february.all())}\")\nprint(f\"February net: {february.sum()}\")\n\n# Filter recent transactions (last 30 days from March 1)\nrecent_cutoff = datetime(2024, 2, 1)  # 30 days before March 1\nrecent = personal_cf.query.filter_by(datetime__gte=recent_cutoff)\n\nprint(f\"Recent transactions: {len(recent.all())}\")\nprint(f\"Recent net: {recent.sum()}\")\n\n# Combine filters: Food expenses in February\nfeb_food = personal_cf.query.filter_by(\n    category=\"food\",\n    datetime__gte=datetime(2024, 2, 1),\n    datetime__lt=datetime(2024, 3, 1)\n)\n\nprint(f\"February food spending: {feb_food.sum()}\")\n</code></pre>"},{"location":"examples/cash_flow/#advanced-query-operations","title":"Advanced Query Operations","text":"<pre><code># Multiple categories\nessential_categories = [\"housing\", \"food\", \"utilities\"]\nessentials = personal_cf.query.filter_by(category__in=essential_categories)\nprint(f\"Essential expenses: {essentials.sum()}\")\n\n# Exclude categories  \nnon_income = personal_cf.query.exclude(category=\"income\")\nprint(f\"Total expenses: {non_income.sum()}\")\n\n# Amount-based filtering\nlarge_expenses = personal_cf.query.filter_by(amount__lt=Money(\"-200.00\"))\nprint(f\"Large expenses (&gt;$200): {large_expenses.sum()}\")\n\n# Get specific items\nall_transactions = personal_cf.query.all()\nfirst_transaction = personal_cf.query.first()\nprint(f\"First transaction: {first_transaction}\")\n</code></pre>"},{"location":"examples/cash_flow/#real-world-example-investment-portfolio-analysis","title":"Real-World Example: Investment Portfolio Analysis","text":"<pre><code>def analyze_investment_portfolio():\n    \"\"\"Analyze a diversified investment portfolio.\"\"\"\n\n    # Portfolio transactions over 1 year\n    portfolio_transactions = [\n        # Initial investments (January)\n        CashFlowItem(Money(\"-10000.00\"), datetime(2024, 1, 15), \"S&amp;P 500 ETF\", \"stocks\"),\n        CashFlowItem(Money(\"-5000.00\"), datetime(2024, 1, 15), \"Bond ETF\", \"bonds\"),\n        CashFlowItem(Money(\"-2000.00\"), datetime(2024, 1, 15), \"REIT ETF\", \"reits\"),\n\n        # Quarterly dividends\n        CashFlowItem(Money(\"125.00\"), datetime(2024, 3, 31), \"S&amp;P 500 dividend\", \"dividends\"),\n        CashFlowItem(Money(\"87.50\"), datetime(2024, 3, 31), \"Bond dividend\", \"dividends\"),\n        CashFlowItem(Money(\"45.00\"), datetime(2024, 3, 31), \"REIT dividend\", \"dividends\"),\n\n        CashFlowItem(Money(\"130.00\"), datetime(2024, 6, 30), \"S&amp;P 500 dividend\", \"dividends\"),\n        CashFlowItem(Money(\"90.00\"), datetime(2024, 6, 30), \"Bond dividend\", \"dividends\"),\n        CashFlowItem(Money(\"48.00\"), datetime(2024, 6, 30), \"REIT dividend\", \"dividends\"),\n\n        CashFlowItem(Money(\"135.00\"), datetime(2024, 9, 30), \"S&amp;P 500 dividend\", \"dividends\"),\n        CashFlowItem(Money(\"92.50\"), datetime(2024, 9, 30), \"Bond dividend\", \"dividends\"),\n        CashFlowItem(Money(\"50.00\"), datetime(2024, 9, 30), \"REIT dividend\", \"dividends\"),\n\n        CashFlowItem(Money(\"140.00\"), datetime(2024, 12, 31), \"S&amp;P 500 dividend\", \"dividends\"),\n        CashFlowItem(Money(\"95.00\"), datetime(2024, 12, 31), \"Bond dividend\", \"dividends\"),\n        CashFlowItem(Money(\"52.00\"), datetime(2024, 12, 31), \"REIT dividend\", \"dividends\"),\n\n        # Rebalancing (mid-year)\n        CashFlowItem(Money(\"-1000.00\"), datetime(2024, 7, 15), \"Additional S&amp;P investment\", \"stocks\"),\n\n        # Year-end values (theoretical sales)\n        CashFlowItem(Money(\"12100.00\"), datetime(2024, 12, 31), \"S&amp;P 500 value\", \"stocks\"),\n        CashFlowItem(Money(\"5150.00\"), datetime(2024, 12, 31), \"Bond value\", \"bonds\"),\n        CashFlowItem(Money(\"2080.00\"), datetime(2024, 12, 31), \"REIT value\", \"reits\"),\n    ]\n\n    portfolio = CashFlow(portfolio_transactions)\n\n    # Analysis by asset class\n    print(\"Portfolio Analysis:\")\n    print(\"=\" * 50)\n\n    stocks = portfolio.query.filter_by(category=\"stocks\")\n    bonds = portfolio.query.filter_by(category=\"bonds\")\n    reits = portfolio.query.filter_by(category=\"reits\")\n    dividends = portfolio.query.filter_by(category=\"dividends\")\n\n    print(f\"Stocks net: {stocks.sum()}\")\n    print(f\"Bonds net: {bonds.sum()}\")\n    print(f\"REITs net: {reits.sum()}\")\n    print(f\"Total dividends: {dividends.sum()}\")\n    print(f\"Portfolio net: {portfolio.sum()}\")\n\n    # Calculate returns\n    initial_investment = Money(\"17000.00\")  # 10k + 5k + 2k\n    additional_investment = Money(\"1000.00\")\n    total_invested = initial_investment + additional_investment\n    final_value = Money(\"19330.00\")  # 12.1k + 5.15k + 2.08k\n    total_dividends = dividends.sum()\n\n    capital_gains = final_value - total_invested\n    total_return = capital_gains + total_dividends\n    return_percentage = (total_return / total_invested) * 100\n\n    print(f\"\\nReturn Analysis:\")\n    print(f\"Total invested: {total_invested}\")\n    print(f\"Final value: {final_value}\")\n    print(f\"Capital gains: {capital_gains}\")\n    print(f\"Dividend income: {total_dividends}\")\n    print(f\"Total return: {total_return}\")\n    print(f\"Return percentage: {return_percentage:.2f}%\")\n\n    # Monthly dividend analysis\n    monthly_dividends = {}\n    for item in dividends.all():\n        month_key = item.datetime.strftime(\"%Y-%m\")\n        if month_key not in monthly_dividends:\n            monthly_dividends[month_key] = Money.zero()\n        monthly_dividends[month_key] += item.amount\n\n    print(f\"\\nQuarterly Dividend Income:\")\n    for month, amount in monthly_dividends.items():\n        print(f\"{month}: {amount}\")\n\nanalyze_investment_portfolio()\n</code></pre>"},{"location":"examples/cash_flow/#business-cash-flow-analysis","title":"Business Cash Flow Analysis","text":"<pre><code>def analyze_business_cash_flow():\n    \"\"\"Analyze business cash flow with seasonal patterns.\"\"\"\n\n    # Small business cash flow (quarterly data)\n    business_transactions = [\n        # Q1 - Slow season\n        CashFlowItem(Money(\"15000.00\"), datetime(2024, 1, 31), \"Q1 Revenue\", \"revenue\"),\n        CashFlowItem(Money(\"-8000.00\"), datetime(2024, 1, 31), \"Salaries\", \"payroll\"),\n        CashFlowItem(Money(\"-2500.00\"), datetime(2024, 1, 31), \"Rent\", \"overhead\"),\n        CashFlowItem(Money(\"-1200.00\"), datetime(2024, 1, 31), \"Utilities\", \"overhead\"),\n        CashFlowItem(Money(\"-800.00\"), datetime(2024, 1, 31), \"Marketing\", \"marketing\"),\n\n        # Q2 - Growing season\n        CashFlowItem(Money(\"22000.00\"), datetime(2024, 4, 30), \"Q2 Revenue\", \"revenue\"),\n        CashFlowItem(Money(\"-9000.00\"), datetime(2024, 4, 30), \"Salaries\", \"payroll\"),\n        CashFlowItem(Money(\"-2500.00\"), datetime(2024, 4, 30), \"Rent\", \"overhead\"),\n        CashFlowItem(Money(\"-1100.00\"), datetime(2024, 4, 30), \"Utilities\", \"overhead\"),\n        CashFlowItem(Money(\"-1500.00\"), datetime(2024, 4, 30), \"Marketing\", \"marketing\"),\n\n        # Q3 - Peak season\n        CashFlowItem(Money(\"35000.00\"), datetime(2024, 7, 31), \"Q3 Revenue\", \"revenue\"),\n        CashFlowItem(Money(\"-12000.00\"), datetime(2024, 7, 31), \"Salaries + Bonus\", \"payroll\"),\n        CashFlowItem(Money(\"-2500.00\"), datetime(2024, 7, 31), \"Rent\", \"overhead\"),\n        CashFlowItem(Money(\"-1400.00\"), datetime(2024, 7, 31), \"Utilities\", \"overhead\"),\n        CashFlowItem(Money(\"-2000.00\"), datetime(2024, 7, 31), \"Marketing\", \"marketing\"),\n\n        # Q4 - Holiday season\n        CashFlowItem(Money(\"28000.00\"), datetime(2024, 10, 31), \"Q4 Revenue\", \"revenue\"),\n        CashFlowItem(Money(\"-10000.00\"), datetime(2024, 10, 31), \"Salaries\", \"payroll\"),\n        CashFlowItem(Money(\"-2500.00\"), datetime(2024, 10, 31), \"Rent\", \"overhead\"),\n        CashFlowItem(Money(\"-1300.00\"), datetime(2024, 10, 31), \"Utilities\", \"overhead\"),\n        CashFlowItem(Money(\"-1800.00\"), datetime(2024, 10, 31), \"Marketing\", \"marketing\"),\n    ]\n\n    business_cf = CashFlow(business_transactions)\n\n    # Category analysis\n    revenue = business_cf.query.filter_by(category=\"revenue\")\n    payroll = business_cf.query.filter_by(category=\"payroll\")\n    overhead = business_cf.query.filter_by(category=\"overhead\")\n    marketing = business_cf.query.filter_by(category=\"marketing\")\n\n    print(\"Annual Business Analysis:\")\n    print(\"=\" * 40)\n    print(f\"Total Revenue: {revenue.sum()}\")\n    print(f\"Payroll Costs: {payroll.sum()}\")\n    print(f\"Overhead Costs: {overhead.sum()}\")\n    print(f\"Marketing Costs: {marketing.sum()}\")\n    print(f\"Net Profit: {business_cf.sum()}\")\n\n    # Quarterly breakdown\n    quarters = [\n        (\"Q1\", datetime(2024, 1, 1), datetime(2024, 4, 1)),\n        (\"Q2\", datetime(2024, 4, 1), datetime(2024, 7, 1)),\n        (\"Q3\", datetime(2024, 7, 1), datetime(2024, 10, 1)),\n        (\"Q4\", datetime(2024, 10, 1), datetime(2025, 1, 1)),\n    ]\n\n    print(f\"\\nQuarterly Performance:\")\n    for quarter, start, end in quarters:\n        q_cf = business_cf.query.filter_by(\n            datetime__gte=start,\n            datetime__lt=end\n        )\n        q_revenue = q_cf.filter_by(category=\"revenue\").sum()\n        q_expenses = q_cf.exclude(category=\"revenue\").sum()\n        q_profit = q_cf.sum()\n        margin = (q_profit / q_revenue) * 100 if q_revenue &gt; Money.zero() else 0\n\n        print(f\"{quarter}: Revenue {q_revenue}, Expenses {q_expenses}, Profit {q_profit} ({margin:.1f}% margin)\")\n\nanalyze_business_cash_flow()\n</code></pre>"},{"location":"examples/cash_flow/#cash-flow-patterns-and-utilities","title":"Cash Flow Patterns and Utilities","text":"<pre><code># Create repeating patterns\ndef create_monthly_salary(amount, start_date, months):\n    \"\"\"Create monthly salary payments.\"\"\"\n    from datetime import timedelta\n\n    transactions = []\n    current_date = start_date\n\n    for i in range(months):\n        transactions.append(\n            CashFlowItem(\n                Money(amount),\n                current_date,\n                f\"Salary - Month {i+1}\",\n                \"salary\"\n            )\n        )\n        # Approximate monthly increment (30 days)\n        current_date += timedelta(days=30)\n\n    return transactions\n\n# Generate salary cash flow\nsalary_cf = CashFlow(create_monthly_salary(\"5000.00\", datetime(2024, 1, 1), 12))\nprint(f\"Annual salary: {salary_cf.sum()}\")\n\n# Cash flow statistics\ndef cash_flow_stats(cf):\n    \"\"\"Calculate cash flow statistics.\"\"\"\n    amounts = [item.amount for item in cf.items()]\n\n    inflows = [amt for amt in amounts if amt.is_positive()]\n    outflows = [amt for amt in amounts if amt.is_negative()]\n\n    total_inflows = sum(inflows, Money.zero())\n    total_outflows = sum(outflows, Money.zero())\n\n    print(f\"Cash Flow Statistics:\")\n    print(f\"Total transactions: {len(amounts)}\")\n    print(f\"Inflows: {len(inflows)} transactions, {total_inflows}\")\n    print(f\"Outflows: {len(outflows)} transactions, {total_outflows}\")\n    print(f\"Net flow: {cf.sum()}\")\n    print(f\"Average transaction: {cf.sum() / len(amounts) if amounts else Money.zero()}\")\n\ncash_flow_stats(personal_cf)\n</code></pre>"},{"location":"examples/cash_flow/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent categories: Use standardized category names for better querying</li> <li>Detailed descriptions: Include meaningful descriptions for transaction tracking</li> <li>Precise timestamps: Use specific datetime objects for accurate analysis</li> <li>Logical grouping: Group related transactions for easier analysis</li> <li>Regular analysis: Periodically analyze cash flows to identify patterns</li> </ol>"},{"location":"examples/cash_flow/#common-patterns","title":"Common Patterns","text":"<pre><code># Monthly expense tracking\ndef monthly_expenses(cash_flow, year, month):\n    start = datetime(year, month, 1)\n    if month == 12:\n        end = datetime(year + 1, 1, 1)\n    else:\n        end = datetime(year, month + 1, 1)\n\n    return cash_flow.query.filter_by(\n        datetime__gte=start,\n        datetime__lt=end\n    ).exclude(category=\"income\")\n\n# Category budgeting\ndef budget_analysis(cash_flow, budget_dict):\n    \"\"\"Compare actual spending to budget.\"\"\"\n    for category, budget in budget_dict.items():\n        actual = cash_flow.query.filter_by(category=category).sum()\n        variance = actual - Money(budget)\n        status = \"OVER\" if variance.is_positive() else \"UNDER\"\n        print(f\"{category}: Budget {Money(budget)}, Actual {actual}, {status} by {abs(variance)}\")\n\n# Cash flow forecasting\ndef forecast_cash_flow(historical_cf, months_ahead):\n    \"\"\"Simple cash flow forecasting based on historical averages.\"\"\"\n    # This is a simplified example - real forecasting would be more sophisticated\n    monthly_avg = historical_cf.sum() / 12  # Assuming 12 months of data\n    return monthly_avg * months_ahead\n</code></pre> <p>Cash flows are the foundation of all financial analysis in MoneyWarp! \ud83d\udcb8</p>"},{"location":"examples/date_generation/","title":"Date Generation Utilities","text":"<p>MoneyWarp provides convenient date generation functions powered by <code>python-dateutil</code> for robust and intelligent date arithmetic.</p>"},{"location":"examples/date_generation/#why-date-generation-matters","title":"Why Date Generation Matters","text":"<p>Creating payment schedules manually is error-prone and tedious:</p> <pre><code># \u274c Manual date creation (error-prone)\nfrom datetime import datetime, timedelta\n\nstart_date = datetime(2024, 1, 31)\ndue_dates = []\nfor i in range(12):\n    # This breaks for months with different lengths!\n    due_dates.append(start_date + timedelta(days=30*i))\n</code></pre> <p>MoneyWarp's date utilities handle edge cases automatically:</p> <pre><code># \u2705 Smart date generation (robust)\nfrom money_warp import generate_monthly_dates\nfrom datetime import datetime\n\ndue_dates = generate_monthly_dates(datetime(2024, 1, 31), 12)\n# Handles Feb 29, month lengths, leap years automatically!\n</code></pre>"},{"location":"examples/date_generation/#available-functions","title":"Available Functions","text":""},{"location":"examples/date_generation/#monthly-dates","title":"Monthly Dates","text":"<p>Generate monthly payment schedules with intelligent end-of-month handling:</p> <pre><code>from money_warp import generate_monthly_dates\nfrom datetime import datetime\n\n# Basic monthly dates\ndates = generate_monthly_dates(datetime(2024, 1, 15), 12)\nprint(f\"12 monthly payments starting Jan 15\")\n\n# End-of-month intelligence\neom_dates = generate_monthly_dates(datetime(2024, 1, 31), 4)\n# Results: [Jan 31, Feb 29, Mar 31, Apr 30]\n# Each date anchors to the original day (31st), clamped per month\n</code></pre>"},{"location":"examples/date_generation/#bi-weekly-dates","title":"Bi-weekly Dates","text":"<p>Perfect for payroll-aligned payment schedules:</p> <pre><code>from money_warp import generate_biweekly_dates\n\n# 26 bi-weekly payments (roughly 1 year)\ndates = generate_biweekly_dates(datetime(2024, 1, 1), 26)\nprint(f\"Payment every 14 days\")\n\n# Great for matching payroll schedules\npayroll_dates = generate_biweekly_dates(datetime(2024, 1, 5), 26)  # Fridays\n</code></pre>"},{"location":"examples/date_generation/#weekly-dates","title":"Weekly Dates","text":"<p>For high-frequency payment schedules:</p> <pre><code>from money_warp import generate_weekly_dates\n\n# Weekly payments for a year\ndates = generate_weekly_dates(datetime(2024, 1, 1), 52)\nprint(f\"52 weekly payments\")\n</code></pre>"},{"location":"examples/date_generation/#quarterly-dates","title":"Quarterly Dates","text":"<p>Business-friendly quarterly schedules:</p> <pre><code>from money_warp import generate_quarterly_dates\n\n# Quarterly payments\ndates = generate_quarterly_dates(datetime(2024, 1, 15), 8)  # 2 years\nprint(f\"Quarterly payments: Q1, Q2, Q3, Q4...\")\n\n# End-of-quarter example\nquarter_end = generate_quarterly_dates(datetime(2024, 3, 31), 4)\n# Results: [Mar 31, Jun 30, Sep 30, Dec 31]\n# Anchors to original day (31st), clamped for 30-day months\n</code></pre>"},{"location":"examples/date_generation/#annual-dates","title":"Annual Dates","text":"<p>For long-term loans and investments:</p> <pre><code>from money_warp import generate_annual_dates\n\n# 30-year mortgage payments\ndates = generate_annual_dates(datetime(2024, 1, 1), 30)\n\n# Leap year handling\nleap_dates = generate_annual_dates(datetime(2024, 2, 29), 5)\n# Results: [2024-02-29, 2025-02-28, 2026-02-28, 2027-02-28, 2028-02-29]\n# Anchors to 29th \u2014 returns to Feb 29 when the next leap year arrives\n</code></pre>"},{"location":"examples/date_generation/#custom-intervals","title":"Custom Intervals","text":"<p>For any custom payment frequency:</p> <pre><code>from money_warp import generate_custom_interval_dates\n\n# Every 45 days\ndates = generate_custom_interval_dates(datetime(2024, 1, 1), 8, 45)\n\n# Every 10 days (short-term financing)\nshort_term = generate_custom_interval_dates(datetime(2024, 1, 1), 12, 10)\n</code></pre>"},{"location":"examples/date_generation/#integration-with-loans","title":"Integration with Loans","text":"<p>All date generation functions work seamlessly with MoneyWarp loans:</p> <pre><code>from money_warp import Loan, Money, InterestRate, generate_monthly_dates\nfrom datetime import datetime\n\n# Generate payment dates\ndue_dates = generate_monthly_dates(datetime(2024, 1, 15), 24)\n\n# Create loan with generated dates\nloan = Loan(\n    principal=Money(\"25000\"),\n    interest_rate=InterestRate(\"4.5% annual\"),\n    due_dates=due_dates\n)\n\n# Get payment schedule\nschedule = loan.get_amortization_schedule()\nprint(f\"Monthly payment: {schedule[0].payment_amount}\")\n</code></pre>"},{"location":"examples/date_generation/#edge-cases-handled","title":"Edge Cases Handled","text":""},{"location":"examples/date_generation/#end-of-month-intelligence","title":"End-of-Month Intelligence","text":"<pre><code># Starting on January 31st\ndates = generate_monthly_dates(datetime(2024, 1, 31), 6)\n\n# Results (each date anchored to original day 31):\n# Jan 31 (start)\n# Feb 29 (leap year, clamped from 31)\n# Mar 31 (back to 31)\n# Apr 30 (April has 30 days, clamped)\n# May 31 (back to 31)\n# Jun 30 (June has 30 days, clamped)\n\nfor i, date in enumerate(dates, 1):\n    print(f\"Payment {i}: {date} (day {date.day})\")\n</code></pre>"},{"location":"examples/date_generation/#leap-year-handling","title":"Leap Year Handling","text":"<pre><code># Annual payments starting on leap day\nleap_dates = generate_annual_dates(datetime(2024, 2, 29), 5)\n\n# Results (anchored to 29th):\n# 2024-02-29 (leap year)\n# 2025-02-28 (not leap year, clamped)\n# 2026-02-28 (not leap year, clamped)\n# 2027-02-28 (not leap year, clamped)\n# 2028-02-29 (leap year again, back to 29)\n</code></pre>"},{"location":"examples/date_generation/#quarter-end-variations","title":"Quarter-End Variations","text":"<pre><code># Starting at end of March (31 days)\nquarter_dates = generate_quarterly_dates(datetime(2024, 3, 31), 4)\n\n# Results (anchored to 31st):\n# Mar 31 (start)\n# Jun 30 (June has 30 days, clamped)\n# Sep 30 (September has 30 days, clamped)\n# Dec 31 (back to 31)\n</code></pre>"},{"location":"examples/date_generation/#real-world-examples","title":"Real-World Examples","text":""},{"location":"examples/date_generation/#mortgage-with-monthly-payments","title":"Mortgage with Monthly Payments","text":"<pre><code>from money_warp import Loan, Money, InterestRate, generate_monthly_dates\nfrom datetime import datetime\n\n# 30-year mortgage starting mid-month\nstart_date = datetime(2024, 1, 15)\npayment_dates = generate_monthly_dates(start_date, 360)  # 30 years * 12 months\n\nmortgage = Loan(\n    principal=Money(\"400000\"),  # $400k house\n    interest_rate=InterestRate(\"6.5% annual\"),\n    due_dates=payment_dates\n)\n\nprint(f\"30-year mortgage with {len(payment_dates)} payments\")\nprint(f\"First payment: {payment_dates[0]}\")\nprint(f\"Final payment: {payment_dates[-1]}\")\n</code></pre>"},{"location":"examples/date_generation/#bi-weekly-auto-loan","title":"Bi-weekly Auto Loan","text":"<pre><code># Bi-weekly auto loan (pays off faster)\nbiweekly_dates = generate_biweekly_dates(datetime(2024, 1, 5), 130)  # ~5 years\n\nauto_loan = Loan(\n    principal=Money(\"35000\"),\n    interest_rate=InterestRate(\"7.2% annual\"),\n    due_dates=biweekly_dates\n)\n\nprint(f\"Bi-weekly auto loan: {len(biweekly_dates)} payments\")\n</code></pre>"},{"location":"examples/date_generation/#business-quarterly-loan","title":"Business Quarterly Loan","text":"<pre><code># Business loan with quarterly payments\nquarterly_dates = generate_quarterly_dates(datetime(2024, 3, 31), 20)  # 5 years\n\nbusiness_loan = Loan(\n    principal=Money(\"100000\"),\n    interest_rate=InterestRate(\"8.5% annual\"),\n    due_dates=quarterly_dates\n)\n\nprint(f\"Business loan: {len(quarterly_dates)} quarterly payments\")\n</code></pre>"},{"location":"examples/date_generation/#api-reference","title":"API Reference","text":""},{"location":"examples/date_generation/#function-signatures","title":"Function Signatures","text":"<pre><code>def generate_monthly_dates(start_date: datetime, num_payments: int) -&gt; List[datetime]:\n    \"\"\"Generate monthly payment dates with smart end-of-month handling.\"\"\"\n\ndef generate_biweekly_dates(start_date: datetime, num_payments: int) -&gt; List[datetime]:\n    \"\"\"Generate bi-weekly payment dates (every 14 days).\"\"\"\n\ndef generate_weekly_dates(start_date: datetime, num_payments: int) -&gt; List[datetime]:\n    \"\"\"Generate weekly payment dates (every 7 days).\"\"\"\n\ndef generate_quarterly_dates(start_date: datetime, num_payments: int) -&gt; List[datetime]:\n    \"\"\"Generate quarterly payment dates (every 3 months).\"\"\"\n\ndef generate_annual_dates(start_date: datetime, num_payments: int) -&gt; List[datetime]:\n    \"\"\"Generate annual payment dates (every 12 months).\"\"\"\n\ndef generate_custom_interval_dates(\n    start_date: datetime, num_payments: int, interval_days: int\n) -&gt; List[datetime]:\n    \"\"\"Generate payment dates with custom day intervals.\"\"\"\n</code></pre>"},{"location":"examples/date_generation/#error-handling","title":"Error Handling","text":"<p>All functions validate inputs and raise clear errors:</p> <pre><code># Invalid payment count\ntry:\n    generate_monthly_dates(datetime(2024, 1, 1), 0)\nexcept ValueError as e:\n    print(e)  # \"Number of payments must be positive\"\n\n# Invalid interval\ntry:\n    generate_custom_interval_dates(datetime(2024, 1, 1), 5, -1)\nexcept ValueError as e:\n    print(e)  # \"Interval days must be positive\"\n</code></pre>"},{"location":"examples/date_generation/#key-benefits","title":"Key Benefits","text":""},{"location":"examples/date_generation/#robust-date-arithmetic","title":"Robust Date Arithmetic","text":"<ul> <li>Powered by python-dateutil: Industry-standard date manipulation</li> <li>Smart month handling: Handles varying month lengths automatically</li> <li>Leap year aware: Correctly handles February 29th edge cases</li> </ul>"},{"location":"examples/date_generation/#simple-api","title":"Simple API","text":"<ul> <li>Type-safe: Full type annotations and validation</li> <li>Minimal parameters: Just <code>datetime</code> and <code>int</code>, no complex options</li> <li>Consistent behavior: All functions follow the same patterns</li> </ul>"},{"location":"examples/date_generation/#immediate-integration","title":"Immediate Integration","text":"<ul> <li>Loan compatibility: Generated dates work directly with <code>Loan</code> objects</li> <li>Time Machine support: All dates work with <code>Warp</code> for temporal analysis</li> <li>Schedule generation: Seamless integration with payment schedulers</li> </ul> <p>MoneyWarp's date utilities eliminate the complexity and bugs of manual date arithmetic, letting you focus on financial modeling instead of calendar math!</p>"},{"location":"examples/fines/","title":"Fines, Mora Interest &amp; Payment Methods","text":"<p>MoneyWarp models late payments realistically: overdue installments incur fines (a flat percentage of the missed amount) and mora interest (extra daily-compounded interest for the days beyond the due date). Payments are always allocated in strict priority: fines first, then interest, then principal.</p> <p>All payment methods return a Settlement object showing exactly how the payment was allocated (see Installments &amp; Settlements below).</p>"},{"location":"examples/fines/#payment-methods","title":"Payment Methods","text":"<p>MoneyWarp provides two sugar methods for recording payments, plus a low-level method for full control.</p>"},{"location":"examples/fines/#pay_installment-the-common-case","title":"<code>pay_installment()</code> \u2014 The Common Case","text":"<p>Records a payment at the current date (<code>self.now()</code>). Interest accrual depends on timing:</p> <ul> <li>Early or on-time: interest accrues up to the due date (no discount)</li> <li>Late: interest accrues up to <code>self.now()</code>, charging extra interest for the overdue days</li> </ul> <pre><code>from datetime import datetime\nfrom money_warp import Loan, Money, InterestRate, Warp, generate_monthly_dates\n\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    generate_monthly_dates(datetime(2024, 2, 1), 12),\n)\n\n# Pay on time using the Time Machine\nwith Warp(loan, datetime(2024, 2, 1)) as warped:\n    warped.pay_installment(Money(\"856.07\"), \"February payment\")\n\n# Pay late \u2014 mora interest is automatically charged\nwith Warp(loan, datetime(2024, 3, 15)) as warped:\n    warped.pay_installment(Money(\"900.00\"), \"March payment (late)\")\n</code></pre>"},{"location":"examples/fines/#anticipate_payment-early-payment-with-discount","title":"<code>anticipate_payment()</code> \u2014 Early Payment with Discount","text":"<p>Records a payment at the current date, but calculates interest only up to <code>self.now()</code>. Fewer elapsed days means less interest charged \u2014 the borrower gets a discount.</p> <pre><code># Anticipate a payment before the due date \u2014 pay less interest\nwith Warp(loan, datetime(2024, 3, 20)) as warped:\n    warped.anticipate_payment(Money(\"800.00\"), \"Early April payment\")\n</code></pre>"},{"location":"examples/fines/#record_payment-explicit-date-control","title":"<code>record_payment()</code> \u2014 Explicit Date Control","text":"<p>Sets both <code>payment_date</code> and <code>interest_date</code> to the given date. Useful for batch processing and tests where you need explicit dates.</p> <pre><code>loan.record_payment(Money(\"856.07\"), datetime(2024, 2, 1), \"February payment\")\nloan.record_payment(Money(\"856.07\"), datetime(2024, 3, 1), \"March payment\")\n</code></pre>"},{"location":"examples/fines/#fine-configuration","title":"Fine Configuration","text":"<p>Configure fines and grace periods when creating a loan:</p> <pre><code>from decimal import Decimal\n\n# Default: 2% fine, no grace period\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    generate_monthly_dates(datetime(2024, 2, 1), 12),\n)\n\n# Custom: 5% fine with a 7-day grace period\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    generate_monthly_dates(datetime(2024, 2, 1), 12),\n    fine_rate=Decimal(\"0.05\"),\n    grace_period_days=7,\n)\n</code></pre> Parameter Default Meaning <code>fine_rate</code> <code>0.02</code> (2%) Fine as a fraction of the expected installment amount <code>grace_period_days</code> <code>0</code> Days after the due date before fines are applied"},{"location":"examples/fines/#how-fines-work","title":"How Fines Work","text":""},{"location":"examples/fines/#checking-for-late-payments","title":"Checking for Late Payments","text":"<pre><code>from datetime import datetime\nfrom money_warp import Loan, Money, InterestRate, generate_monthly_dates\n\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    generate_monthly_dates(datetime(2024, 2, 1), 3),\n)\n\n# Is the February payment late as of February 15?\nis_late = loan.is_payment_late(datetime(2024, 2, 1), as_of_date=datetime(2024, 2, 15))\nprint(f\"Late? {is_late}\")  # True \u2014 no payment was made\n</code></pre>"},{"location":"examples/fines/#calculating-and-applying-fines","title":"Calculating and Applying Fines","text":"<p><code>calculate_late_fines()</code> scans all due dates up to the given date and applies one fine per missed due date. Fines are never duplicated \u2014 each due date can only be fined once.</p> <pre><code># Apply fines as of March 15 (both Feb and March installments missed)\nnew_fines = loan.calculate_late_fines(as_of_date=datetime(2024, 3, 15))\nprint(f\"New fines applied: {new_fines}\")\nprint(f\"Total fines: {loan.total_fines}\")\nprint(f\"Outstanding fines: {loan.outstanding_fines}\")\n</code></pre>"},{"location":"examples/fines/#fine-amounts-come-from-the-original-schedule","title":"Fine Amounts Come from the Original Schedule","text":"<p>Fines are calculated as <code>fine_rate * expected_payment_amount</code>, where the expected payment comes from the original amortization schedule \u2014 not the rebuilt schedule. This ensures fine amounts are predictable and don't change as payments are recorded.</p>"},{"location":"examples/fines/#mora-interest","title":"Mora Interest","text":"<p>When a borrower pays late, they are charged extra interest for the days beyond the due date. The interest is automatically split into two separate cash flow items:</p> <ul> <li>Regular interest (<code>\"actual_interest\"</code>) \u2014 accrued from the last payment to the due date</li> <li>Mora interest (<code>\"actual_mora_interest\"</code>) \u2014 accrued from the due date to the payment date</li> </ul> <p>On-time and early payments produce only a regular interest item (no mora).</p> <pre><code>loan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"6% a\"),\n    [datetime(2024, 2, 1), datetime(2024, 3, 1), datetime(2024, 4, 1)],\n    disbursement_date=datetime(2024, 1, 1),\n)\n\n# Miss installment 1, pay 2 weeks late\n# The borrower pays:\n#   1. A fine (2% of the expected installment)\n#   2. Regular interest for 31 days (disbursement to due date)\n#   3. Mora interest for 14 days (due date to payment date)\n#   4. The remaining amount reduces principal\nwith Warp(loan, datetime(2024, 2, 15)) as warped:\n    warped.pay_installment(Money(\"3600.00\"), \"Late payment\")\n    print(f\"Outstanding fines: {warped.outstanding_fines}\")\n    print(f\"Remaining balance: {warped.current_balance}\")\n</code></pre>"},{"location":"examples/fines/#payment-allocation-priority","title":"Payment Allocation Priority","text":"<p>All payment methods allocate funds in the same strict order:</p> <ol> <li>Outstanding fines \u2014 paid off first</li> <li>Accrued interest \u2014 daily-compounded since last payment, up to the interest date</li> <li>Principal \u2014 whatever remains reduces the loan balance</li> </ol> <p>A large late payment naturally covers the missed installment and eats into future installments through this allocation pipeline. There is no special-casing \u2014 the allocation priority and principal balance tracking handle overpayments automatically.</p>"},{"location":"examples/fines/#grace-periods","title":"Grace Periods","text":"<p>A grace period delays when fines are applied. If <code>grace_period_days=7</code>, a payment due on February 1st is not considered late until February 8th.</p> <pre><code>from decimal import Decimal\n\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    [datetime(2024, 2, 1)],\n    grace_period_days=7,\n)\n\n# Not late on February 5 (within grace period)\nprint(loan.is_payment_late(datetime(2024, 2, 1), datetime(2024, 2, 5)))  # False\n\n# Late on February 9 (grace period expired)\nprint(loan.is_payment_late(datetime(2024, 2, 1), datetime(2024, 2, 9)))  # True\n</code></pre> <p>Note: the grace period only affects fines. Mora interest always accrues for every day past the due date, regardless of the grace period.</p>"},{"location":"examples/fines/#tracking-payments-in-cash-flows","title":"Tracking Payments in Cash Flows","text":"<p>All cash flow items use explicit category prefixes. Expected schedule items use <code>expected_</code>, actual recorded payments use <code>actual_</code>:</p> <pre><code>actual_cf = loan.get_actual_cash_flow()\n\n# Query fine application events\nfines = actual_cf.query.filter_by(category=\"fine_applied\").all()\nfor fine in fines:\n    print(f\"{fine.datetime}: {fine.amount} \u2014 {fine.description}\")\n\n# Query mora interest payments\nmora = actual_cf.query.filter_by(category=\"actual_mora_interest\").all()\nfor item in mora:\n    print(f\"{item.datetime}: {item.amount} \u2014 {item.description}\")\n</code></pre>"},{"location":"examples/fines/#cash-flow-categories","title":"Cash Flow Categories","text":"Category Meaning <code>\"expected_disbursement\"</code> Loan disbursement (expected schedule) <code>\"expected_interest\"</code> Scheduled interest payment <code>\"expected_principal\"</code> Scheduled principal payment <code>\"actual_interest\"</code> Regular interest paid (up to due date) <code>\"actual_mora_interest\"</code> Mora interest paid (beyond due date) <code>\"actual_principal\"</code> Principal paid <code>\"actual_fine\"</code> Fine paid <code>\"fine_applied\"</code> Fine applied to loan"},{"location":"examples/fines/#installments-settlements","title":"Installments &amp; Settlements","text":"<p>A loan is not a group of installments. Installments are consequences of the loan \u2014 they describe how the borrower repays. Settlements are consequences of making a payment \u2014 they describe how the money was allocated.</p>"},{"location":"examples/fines/#installments","title":"Installments","text":"<p>Access the repayment plan via <code>loan.installments</code>. Each <code>Installment</code> shows expected amounts, actual paid amounts, and detailed per-payment allocations.</p> <pre><code>from money_warp import Loan, Money, InterestRate, generate_monthly_dates\nfrom datetime import datetime\n\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"6% a\"),\n    generate_monthly_dates(datetime(2025, 2, 1), 3),\n    disbursement_date=datetime(2025, 1, 1),\n)\n\n# Before any payments: all unpaid\nfor inst in loan.installments:\n    print(f\"#{inst.number} due {inst.due_date.date()}: \"\n          f\"{inst.expected_payment} \u2014 paid: {inst.is_fully_paid}\")\n\n# After a payment: first installment is paid\nschedule = loan.get_original_schedule()\nloan.record_payment(schedule[0].payment_amount, schedule[0].due_date)\n\ninst = loan.installments[0]\nprint(f\"#{inst.number} is_fully_paid={inst.is_fully_paid}\")\nprint(f\"  principal_paid={inst.principal_paid}, interest_paid={inst.interest_paid}\")\nprint(f\"  allocations: {len(inst.allocations)}\")\n</code></pre> <p>Installments are Warp-aware \u2014 inside a <code>Warp</code> context, <code>is_fully_paid</code> reflects only payments made by the warped date.</p>"},{"location":"examples/fines/#settlements","title":"Settlements","text":"<p>Every call to <code>record_payment()</code>, <code>pay_installment()</code>, or <code>anticipate_payment()</code> returns a <code>Settlement</code>. You can also access all past settlements via <code>loan.settlements</code>.</p> <pre><code>settlement = loan.record_payment(Money(\"5000\"), datetime(2025, 3, 1))\n\n# Settlement-level totals\nprint(f\"Payment: {settlement.payment_amount}\")\nprint(f\"Fine: {settlement.fine_paid}\")\nprint(f\"Interest: {settlement.interest_paid}\")\nprint(f\"Mora: {settlement.mora_paid}\")\nprint(f\"Principal: {settlement.principal_paid}\")\nprint(f\"Remaining: {settlement.remaining_balance}\")\n\n# Per-installment detail\nfor alloc in settlement.allocations:\n    print(f\"  Installment #{alloc.installment_number}: \"\n          f\"principal={alloc.principal_allocated}, \"\n          f\"interest={alloc.interest_allocated}, \"\n          f\"covered={alloc.is_fully_covered}\")\n\n# Access all settlements\nfor s in loan.settlements:\n    print(f\"{s.payment_date.date()}: {s.payment_amount}\")\n</code></pre> <p>Settlements are not stored as separate state \u2014 they are reconstructed by querying the loan's cash flow data. This means <code>loan.settlements</code> is always consistent with the actual payment history.</p>"},{"location":"examples/fines/#key-properties","title":"Key Properties","text":"Property Type Meaning <code>total_fines</code> <code>Money</code> Sum of all fines ever applied <code>outstanding_fines</code> <code>Money</code> Unpaid fines (total minus what's been paid off) <code>fines_applied</code> <code>Dict[datetime, Money]</code> Fine amount applied per due date <code>is_paid_off</code> <code>bool</code> True only when principal and fines are zero <code>installments</code> <code>List[Installment]</code> Repayment plan with expected/actual amounts (Warp-aware) <code>settlements</code> <code>List[Settlement]</code> Payment allocation history (Warp-aware)"},{"location":"examples/interest_rates/","title":"Interest Rates","text":"<p>The <code>InterestRate</code> class eliminates confusion between decimal and percentage representations while providing safe conversions between different compounding frequencies.</p>"},{"location":"examples/interest_rates/#the-problem-with-raw-numbers","title":"The Problem with Raw Numbers","text":"<p>Interest rates are confusing when represented as raw numbers:</p> <pre><code># Is this 5% or 500%? \ud83e\udd14\nrate = 0.05\n\n# Is this 5% or 0.05%? \ud83e\udd14  \nrate = 5\n\n# MoneyWarp makes it explicit\nfrom money_warp import InterestRate\n\nrate = InterestRate(\"5% a\")  # Clearly 5% annually \u2705\n</code></pre>"},{"location":"examples/interest_rates/#creating-interest-rates","title":"Creating Interest Rates","text":"<p>Multiple clear formats supported:</p> <pre><code>from money_warp import InterestRate, CompoundingFrequency\n\n# String format (recommended)\nannual = InterestRate(\"5.25% a\")        # 5.25% annually\nmonthly = InterestRate(\"0.4375% m\")     # 0.4375% monthly  \ndaily = InterestRate(\"0.0144% d\")       # 0.0144% daily\nquarterly = InterestRate(\"1.3125% q\")   # 1.3125% quarterly\n\n# Long form strings\nannual_long = InterestRate(\"5.25% annual\")\nmonthly_long = InterestRate(\"0.4375% monthly\")\n\n# Abbreviated notation (Brazilian/LatAm convention)\nannual_abbrev = InterestRate(\"5.25% a.a.\")    # ao ano\nmonthly_abbrev = InterestRate(\"0.4375% a.m.\") # ao m\u00eas\ndaily_abbrev = InterestRate(\"0.0144% a.d.\")   # ao dia\nquarterly_abbrev = InterestRate(\"2.75% a.t.\")  # ao trimestre\nsemi_annual_abbrev = InterestRate(\"3% a.s.\")   # ao semestre\n\n# Decimal format (explicit)\ndecimal_annual = InterestRate(\"0.0525 a\")     # 5.25% as decimal\ndecimal_monthly = InterestRate(\"0.004375 m\")  # 0.4375% as decimal\n\n# Numeric with explicit frequency\nnumeric_rate = InterestRate(5.25, CompoundingFrequency.ANNUALLY, as_percentage=True)\n\nprint(f\"Annual: {annual}\")\nprint(f\"Monthly: {monthly}\")\nprint(f\"Daily: {daily}\")\nprint(f\"Quarterly: {quarterly}\")\n</code></pre> <p>Output: <pre><code>Annual: 5.250% annually\nMonthly: 0.438% monthly\nDaily: 0.014% daily\nQuarterly: 1.313% quarterly\n</code></pre></p>"},{"location":"examples/interest_rates/#accessing-rate-values","title":"Accessing Rate Values","text":"<p>Safe access to decimal and percentage representations:</p> <pre><code>rate = InterestRate(\"6.5% a\")\n\nprint(f\"As percentage: {rate.as_percentage}\")  # 6.5\nprint(f\"As decimal: {rate.as_decimal}\")        # 0.065\nprint(f\"Frequency: {rate.period}\")             # CompoundingFrequency.ANNUALLY\nprint(f\"Display: {rate}\")                      # 6.500% annually\n</code></pre>"},{"location":"examples/interest_rates/#frequency-conversions","title":"Frequency Conversions","text":"<p>Convert between different compounding frequencies:</p> <pre><code># Start with annual rate\nannual = InterestRate(\"6% a\")\n\n# Convert to other frequencies\nmonthly = annual.to_monthly()\ndaily = annual.to_daily()\nquarterly = annual.to_quarterly()\n\nprint(f\"Annual: {annual}\")\nprint(f\"Monthly equivalent: {monthly}\")\nprint(f\"Daily equivalent: {daily}\")\nprint(f\"Quarterly equivalent: {quarterly}\")\n</code></pre> <p>Output: <pre><code>Annual: 6.000% annually\nMonthly equivalent: 0.487% monthly\nDaily equivalent: 0.016% daily\nQuarterly equivalent: 1.467% quarterly\n</code></pre></p>"},{"location":"examples/interest_rates/#understanding-effective-vs-nominal-rates","title":"Understanding Effective vs Nominal Rates","text":"<p>MoneyWarp handles the conversion between nominal and effective rates:</p> <pre><code># Nominal 12% annual rate\nnominal = InterestRate(\"12% a\")\n\n# What's the effective monthly rate?\nmonthly_effective = nominal.to_monthly()\nprint(f\"Nominal annual: {nominal}\")\nprint(f\"Effective monthly: {monthly_effective}\")\n\n# Verify: 12 months of monthly rate should equal annual\nannual_check = (1 + monthly_effective.as_decimal) ** 12 - 1\nprint(f\"Verification: {annual_check:.6f} \u2248 {nominal.as_decimal:.6f}\")\n</code></pre> <p>Output: <pre><code>Nominal annual: 12.000% annually\nEffective monthly: 0.949% monthly\nVerification: 0.120000 \u2248 0.120000\n</code></pre></p>"},{"location":"examples/interest_rates/#real-world-example-credit-card-apr","title":"Real-World Example: Credit Card APR","text":"<pre><code>def analyze_credit_card(balance, apr_string, monthly_payment):\n    \"\"\"Analyze credit card payoff with daily compounding.\"\"\"\n\n    from money_warp import Money\n\n    balance = Money(balance)\n    monthly_payment = Money(monthly_payment)\n\n    # Credit cards typically compound daily\n    apr = InterestRate(apr_string)\n    daily_rate = apr.to_daily()\n\n    print(f\"Credit Card Analysis:\")\n    print(f\"Balance: {balance}\")\n    print(f\"APR: {apr}\")\n    print(f\"Daily rate: {daily_rate}\")\n    print(f\"Monthly payment: {monthly_payment}\")\n    print()\n\n    # Calculate monthly interest (30 days)\n    monthly_interest = balance * (daily_rate.as_decimal * 30)\n    principal_payment = monthly_payment - monthly_interest\n\n    print(f\"Monthly breakdown:\")\n    print(f\"  Interest (30 days): {monthly_interest}\")\n    print(f\"  Principal: {principal_payment}\")\n\n    if principal_payment &lt;= Money.zero():\n        print(\"\u26a0\ufe0f  Payment doesn't cover interest!\")\n        return\n\n    # Estimate payoff time (simplified)\n    months = 0\n    current_balance = balance\n\n    while current_balance &gt; Money.zero() and months &lt; 600:  # Max 50 years\n        interest = current_balance * (daily_rate.as_decimal * 30)\n        principal = monthly_payment - interest\n\n        if principal &lt;= Money.zero():\n            break\n\n        current_balance -= principal\n        months += 1\n\n        if current_balance &lt; Money.zero():\n            current_balance = Money.zero()\n\n    print(f\"Estimated payoff: {months} months ({months/12:.1f} years)\")\n    total_paid = monthly_payment * months\n    total_interest = total_paid - balance\n    print(f\"Total paid: {total_paid}\")\n    print(f\"Total interest: {total_interest}\")\n\n# Analyze a typical credit card scenario\nanalyze_credit_card(\"5000.00\", \"18.99% a\", \"150.00\")\n</code></pre> <p>Output: <pre><code>Credit Card Analysis:\nBalance: 5,000.00\nAPR: 18.990% annually\nDaily rate: 0.047% daily\nMonthly payment: 150.00\n\nMonthly breakdown:\n  Interest (30 days): 78.95\n  Principal: 71.05\n\nEstimated payoff: 48 months (4.0 years)\nTotal paid: 7,200.00\nTotal interest: 2,200.00\n</code></pre></p>"},{"location":"examples/interest_rates/#mortgage-rate-comparisons","title":"Mortgage Rate Comparisons","text":"<pre><code>def compare_mortgage_rates(principal, loan_term_years, rates):\n    \"\"\"Compare different mortgage rates.\"\"\"\n\n    from money_warp import Money, Loan\n    from datetime import datetime, timedelta\n\n    principal = Money(principal)\n\n    print(f\"Mortgage Comparison - {principal} over {loan_term_years} years\")\n    print(\"=\" * 60)\n\n    # Generate monthly payment schedule\n    start_date = datetime(2024, 1, 1)\n    num_payments = loan_term_years * 12\n    due_dates = [start_date + timedelta(days=30*i) for i in range(1, num_payments + 1)]\n\n    results = []\n\n    for rate_str in rates:\n        rate = InterestRate(rate_str)\n        loan = Loan(principal, rate, due_dates)\n        schedule = loan.get_amortization_schedule()\n\n        monthly_payment = schedule[0].payment_amount\n        total_interest = schedule.total_interest\n        total_paid = schedule.total_payments\n\n        results.append({\n            'rate': rate,\n            'monthly_payment': monthly_payment,\n            'total_interest': total_interest,\n            'total_paid': total_paid\n        })\n\n        print(f\"{rate_str:&gt;8} | {monthly_payment:&gt;10} | {total_interest:&gt;12} | {total_paid:&gt;12}\")\n\n    # Find best rate\n    best = min(results, key=lambda x: x['total_interest'])\n    worst = max(results, key=lambda x: x['total_interest'])\n    savings = worst['total_interest'] - best['total_interest']\n\n    print(\"=\" * 60)\n    print(f\"Best rate: {best['rate']} saves {savings} vs worst rate\")\n\n# Compare common mortgage rates\nrates = [\"3.5% a\", \"4.0% a\", \"4.5% a\", \"5.0% a\", \"5.5% a\"]\ncompare_mortgage_rates(\"300000.00\", 30, rates)\n</code></pre>"},{"location":"examples/interest_rates/#high-frequency-trading-example","title":"High-Frequency Trading Example","text":"<pre><code>def calculate_compound_returns(principal, daily_rate_pct, days):\n    \"\"\"Calculate returns with daily compounding.\"\"\"\n\n    from money_warp import Money\n\n    principal = Money(principal)\n    daily_rate = InterestRate(f\"{daily_rate_pct}% d\")\n\n    print(f\"Compound Growth Analysis:\")\n    print(f\"Principal: {principal}\")\n    print(f\"Daily rate: {daily_rate}\")\n    print(f\"Period: {days} days\")\n    print()\n\n    # Calculate compound growth\n    growth_factor = (1 + daily_rate.as_decimal) ** days\n    final_amount = principal * growth_factor\n    total_return = final_amount - principal\n\n    # Convert to annual equivalent\n    annual_equivalent = InterestRate(\n        float((growth_factor ** (365/days)) - 1), \n        CompoundingFrequency.ANNUALLY, \n        as_percentage=False\n    )\n\n    print(f\"Final amount: {final_amount}\")\n    print(f\"Total return: {total_return}\")\n    print(f\"Return percentage: {(total_return / principal) * 100:.2f}%\")\n    print(f\"Annualized rate: {annual_equivalent}\")\n\n# Example: 0.1% daily return over 100 days\ncalculate_compound_returns(\"10000.00\", \"0.1\", 100)\n</code></pre>"},{"location":"examples/interest_rates/#custom-periodic-rates","title":"Custom Periodic Rates","text":"<pre><code># For non-standard periods\nrate = InterestRate(\"8% a\")\n\n# Convert to any period (e.g., weekly = 52 periods per year)\nweekly_rate = rate.to_periodic_rate(52)\nprint(f\"Weekly rate: {weekly_rate:.6f}\")\n\n# Bi-weekly (26 periods per year)\nbiweekly_rate = rate.to_periodic_rate(26)\nprint(f\"Bi-weekly rate: {biweekly_rate:.6f}\")\n\n# Custom: every 45 days (365/45 \u2248 8.11 periods per year)\ncustom_periods = 365 / 45\ncustom_rate = rate.to_periodic_rate(custom_periods)\nprint(f\"45-day rate: {custom_rate:.6f}\")\n</code></pre>"},{"location":"examples/interest_rates/#rate-validation-and-error-handling","title":"Rate Validation and Error Handling","text":"<pre><code>try:\n    # Invalid format\n    bad_rate = InterestRate(\"5% x\")  # 'x' is not a valid frequency\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    # Missing frequency for numeric input\n    bad_rate = InterestRate(0.05)  # No frequency specified\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Valid alternatives\ngood_rate1 = InterestRate(0.05, CompoundingFrequency.ANNUALLY, as_percentage=False)\ngood_rate2 = InterestRate(5, CompoundingFrequency.ANNUALLY, as_percentage=True)\ngood_rate3 = InterestRate(\"5% a\")  # Recommended\n\nprint(f\"All equivalent: {good_rate1} = {good_rate2} = {good_rate3}\")\n</code></pre>"},{"location":"examples/interest_rates/#abbreviated-notation-str_style","title":"Abbreviated Notation (str_style)","text":"<p>MoneyWarp supports abbreviated period labels commonly used in Brazilian and Latin American finance. The <code>str_style</code> parameter controls how <code>__str__</code> renders the period:</p> Frequency Long (<code>\"long\"</code>) Abbreviated (<code>\"abbrev\"</code>) Annually <code>5.250% annually</code> <code>5.250% a.a.</code> Monthly <code>0.500% monthly</code> <code>0.500% a.m.</code> Daily <code>0.014% daily</code> <code>0.014% a.d.</code> Quarterly <code>2.750% quarterly</code> <code>2.750% a.t.</code> Semi-annually <code>3.000% semi_annually</code> <code>3.000% a.s.</code>"},{"location":"examples/interest_rates/#auto-detection-from-string-input","title":"Auto-detection from string input","text":"<p>When you parse a string that uses abbreviated tokens, the style is set automatically:</p> <pre><code>rate = InterestRate(\"5.25% a.a.\")\nprint(rate)  # \"5.250% a.a.\" \u2014 round-trips without extra config\n</code></pre>"},{"location":"examples/interest_rates/#explicit-style-on-numeric-rates","title":"Explicit style on numeric rates","text":"<p>For rates created from numbers, pass <code>str_style=\"abbrev\"</code>:</p> <pre><code>rate = InterestRate(\n    1.5, CompoundingFrequency.MONTHLY,\n    as_percentage=True, str_style=\"abbrev\",\n)\nprint(rate)  # \"1.500% a.m.\"\n</code></pre>"},{"location":"examples/interest_rates/#style-propagates-through-conversions","title":"Style propagates through conversions","text":"<p>Converting a rate preserves its display style:</p> <pre><code>annual = InterestRate(\"6% a.a.\")\nmonthly = annual.to_monthly()\ndaily = annual.to_daily()\n\nprint(annual)   # \"6.000% a.a.\"\nprint(monthly)  # \"0.487% a.m.\"\nprint(daily)    # \"0.016% a.d.\"\n</code></pre>"},{"location":"examples/interest_rates/#year-size-day-count-convention","title":"Year Size (Day-Count Convention)","text":"<p>Financial markets use different day-count conventions when converting between daily and annual rates. MoneyWarp supports two conventions through the <code>YearSize</code> enum:</p> Convention Days Typical use <code>YearSize.commercial</code> 365 Calendar-day markets (default) <code>YearSize.banker</code> 360 International banking, some LatAm conventions"},{"location":"examples/interest_rates/#basic-usage","title":"Basic usage","text":"<pre><code>from money_warp import InterestRate, YearSize\n\n# Default: commercial (365 days)\ncommercial = InterestRate(\"10% a\")\nprint(commercial.to_daily())  # 365th root of 1.10\n\n# Banker convention (360 days)\nbanker = InterestRate(\"10% a\", year_size=YearSize.banker)\nprint(banker.to_daily())  # 360th root of 1.10 \u2014 slightly higher daily rate\n</code></pre>"},{"location":"examples/interest_rates/#how-year-size-affects-calculations","title":"How year size affects calculations","text":"<p>The same annual rate produces different daily rates depending on the convention:</p> <pre><code>from money_warp import InterestRate, YearSize, Money\n\nrate_365 = InterestRate(\"10% a\", year_size=YearSize.commercial)\nrate_360 = InterestRate(\"10% a\", year_size=YearSize.banker)\n\nprint(f\"Commercial daily: {rate_365.to_daily().as_decimal:.10f}\")  # ~0.0002611578\nprint(f\"Banker daily:     {rate_360.to_daily().as_decimal:.10f}\")  # ~0.0002651568\n\n# This difference compounds when accruing interest\nprincipal = Money(\"100000\")\nprint(f\"30-day accrual (365): {rate_365.accrue(principal, 30)}\")\nprint(f\"30-day accrual (360): {rate_360.accrue(principal, 30)}\")  # higher\n</code></pre>"},{"location":"examples/interest_rates/#year-size-propagates-through-conversions","title":"Year size propagates through conversions","text":"<p>Once set, the year size carries through all frequency conversions:</p> <pre><code>rate = InterestRate(\"10% a\", year_size=YearSize.banker)\n\ndaily = rate.to_daily()\nmonthly = rate.to_monthly()\nback_to_annual = daily.to_annual()\n\nprint(daily.year_size)           # YearSize.banker\nprint(monthly.year_size)         # YearSize.banker\nprint(back_to_annual.year_size)  # YearSize.banker\n</code></pre>"},{"location":"examples/interest_rates/#inspecting-year-size","title":"Inspecting year size","text":"<pre><code>rate = InterestRate(\"5% a\", year_size=YearSize.banker)\n\nprint(rate.year_size)       # YearSize.banker\nprint(rate.year_size.value) # 360\nprint(repr(rate))           # includes year_size when non-default\n</code></pre>"},{"location":"examples/interest_rates/#best-practices","title":"Best Practices","text":"<ol> <li>Use string format: <code>InterestRate(\"5.25% a\")</code> is clearest</li> <li>Be explicit: Always specify frequency (a/m/d/q/s or a.a./a.m./a.d./a.t./a.s.)</li> <li>Convert appropriately: Match compounding to your calculation needs</li> <li>Validate inputs: Handle user input with try/catch</li> <li>Document assumptions: Make compounding frequency clear in your code</li> <li>Use abbreviated notation when integrating with Brazilian/LatAm financial systems</li> <li>Set <code>year_size</code> when your market uses the 360-day banker convention</li> </ol>"},{"location":"examples/interest_rates/#common-patterns","title":"Common Patterns","text":"<pre><code># Reading rates from configuration\nconfig_rates = {\n    'savings': \"0.5% a\",\n    'checking': \"0.01% a\", \n    'mortgage': \"4.25% a\",\n    'credit_card': \"18.99% a\"\n}\n\nrates = {name: InterestRate(rate_str) for name, rate_str in config_rates.items()}\n\n# Comparing rates (convert to same frequency)\nannual_rates = {name: rate.to_annual() for name, rate in rates.items()}\nfor name, rate in annual_rates.items():\n    print(f\"{name}: {rate}\")\n\n# Finding the best rate\nbest_savings = max(rates['savings'], rates['checking'], key=lambda r: r.as_decimal)\nprint(f\"Best savings rate: {best_savings}\")\n</code></pre> <p>Interest rates are now type-safe and crystal clear! \ud83d\udcc8</p>"},{"location":"examples/money/","title":"Money &amp; Precision","text":"<p>The <code>Money</code> class is the foundation of MoneyWarp, providing high-precision financial calculations while maintaining intuitive 2-decimal display for \"real money\" amounts.</p>"},{"location":"examples/money/#why-precision-matters","title":"Why Precision Matters","text":"<p>Financial calculations require precision. Floating-point arithmetic can introduce errors:</p> <pre><code># The classic floating-point problem\nprint(0.1 + 0.2)  # 0.30000000000000004 \ud83d\ude31\n\n# With MoneyWarp\nfrom money_warp import Money\n\nmoney1 = Money(\"0.1\")\nmoney2 = Money(\"0.2\")\nresult = money1 + money2\nprint(result)  # 0.30 \u2705\n</code></pre>"},{"location":"examples/money/#creating-money-objects","title":"Creating Money Objects","text":"<p>Multiple ways to create <code>Money</code> objects:</p> <pre><code>from money_warp import Money\nfrom decimal import Decimal\n\n# From strings (recommended for precision)\nprice = Money(\"99.99\")\nsalary = Money(\"75000.00\")\n\n# From integers\ncount = Money(100)  # $100.00\n\n# From Decimal (maintains precision)\nprecise = Money(Decimal(\"123.456789\"))\n\n# From floats (converted to string internally)\napprox = Money(99.99)  # Converted to avoid float precision issues\n\nprint(f\"Price: {price}\")\nprint(f\"Salary: {salary}\")\nprint(f\"Count: {count}\")\nprint(f\"Precise: {precise}\")\nprint(f\"Approx: {approx}\")\n</code></pre> <p>Output: <pre><code>Price: 99.99\nSalary: 75,000.00\nCount: 100.00\nPrecise: 123.46\nApprox: 99.99\n</code></pre></p>"},{"location":"examples/money/#precision-vs-display","title":"Precision vs Display","text":"<p>MoneyWarp maintains full precision internally but displays 2 decimals:</p> <pre><code># High precision calculation\nmoney = Money(\"100.123456789\")\n\nprint(f\"Internal (raw): {money.raw_amount}\")    # Full precision\nprint(f\"Display (real): {money.real_amount}\")   # 2 decimals\nprint(f\"String: {money}\")                       # 2 decimals\n</code></pre> <p>Output: <pre><code>Internal (raw): 100.123456789\nDisplay (real): 100.12\nString: 100.12\n</code></pre></p>"},{"location":"examples/money/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>All arithmetic maintains precision internally:</p> <pre><code>base = Money(\"100.00\")\n\n# Basic operations\naddition = base + Money(\"25.50\")\nsubtraction = base - Money(\"15.75\")\nmultiplication = base * 1.08  # 8% increase\ndivision = base / 4\n\nprint(f\"Addition: {addition}\")\nprint(f\"Subtraction: {subtraction}\")\nprint(f\"Multiplication: {multiplication}\")\nprint(f\"Division: {division}\")\n\n# Complex calculations\ncompound = Money(\"1000.00\") * (1.05 ** 10)  # 5% for 10 years\nprint(f\"Compound growth: {compound}\")\n\n# Chain operations\nresult = Money(\"500.00\") * 1.08 / 12 * 365.25 / 100\nprint(f\"Complex chain: {result}\")\nprint(f\"Internal precision: {result.raw_amount}\")\n</code></pre> <p>Output: <pre><code>Addition: 125.50\nSubtraction: 84.25\nMultiplication: 108.00\nDivision: 25.00\nCompound growth: 1,628.89\nComplex chain: 164.25\nInternal precision: 164.2500000000000000000000000\n</code></pre></p>"},{"location":"examples/money/#comparison-operations","title":"Comparison Operations","text":"<p>Comparisons use the 2-decimal \"real money\" representation. You can compare <code>Money</code> against another <code>Money</code> or directly against a <code>Decimal</code>:</p> <pre><code>from decimal import Decimal\n\nmoney1 = Money(\"100.001\")  # Rounds to 100.00\nmoney2 = Money(\"100.009\")  # Rounds to 100.01\n\nprint(f\"Money1: {money1}\")  # 100.00\nprint(f\"Money2: {money2}\")  # 100.01\n\n# Money vs Money\nprint(f\"Equal? {money1 == money2}\")           # False\nprint(f\"Money1 &lt; Money2? {money1 &lt; money2}\") # True\nprint(f\"Money1 &lt;= 100.00? {money1 &lt;= Money('100.00')}\")  # True\n\n# Money vs Decimal -- no need to extract .real_amount\nprint(f\"Equals Decimal? {money1 == Decimal('100.00')}\")  # True\nprint(f\"Greater than? {money2 &gt; Decimal('100.00')}\")     # True\n</code></pre>"},{"location":"examples/money/#working-with-cents","title":"Working with Cents","text":"<p>Avoid decimal issues by working with cents:</p> <pre><code># Create from cents\nprice_in_cents = Money.from_cents(9999)  # $99.99\nprint(f\"From cents: {price_in_cents}\")\n\n# Get cents value\nmoney = Money(\"123.45\")\ncents = money.cents\nprint(f\"As cents: {cents}\")  # 12345\n\n# Useful for APIs that work in cents\napi_amount = Money.from_cents(2500)  # $25.00 from API\nprint(f\"API amount: {api_amount}\")\n</code></pre>"},{"location":"examples/money/#zero-and-utility-methods","title":"Zero and Utility Methods","text":"<p>Convenient methods for common operations:</p> <pre><code># Zero money\nzero = Money.zero()\nprint(f\"Zero: {zero}\")\n\n# Check if zero\nbalance = Money(\"0.00\")\nprint(f\"Is zero? {balance.is_zero()}\")\n\n# Check sign\npositive = Money(\"100.00\")\nnegative = Money(\"-50.00\")\nprint(f\"Positive? {positive.is_positive()}\")\nprint(f\"Negative? {negative.is_negative()}\")\n\n# Absolute value\ndebt = Money(\"-1500.00\")\nprint(f\"Debt: {debt}\")\nprint(f\"Absolute: {abs(debt)}\")\n</code></pre> <p>Output: <pre><code>Zero: 0.00\nIs zero? True\nPositive? True\nNegative? True\nDebt: -1,500.00\nAbsolute: 1,500.00\n</code></pre></p>"},{"location":"examples/money/#real-world-example-tax-calculations","title":"Real-World Example: Tax Calculations","text":"<pre><code>def calculate_tax_breakdown(gross_salary, tax_rate, deductions):\n    \"\"\"Calculate detailed tax breakdown with high precision.\"\"\"\n\n    gross = Money(gross_salary)\n    rate = tax_rate\n    deduct = Money(deductions)\n\n    # Calculate taxable income\n    taxable = gross - deduct\n\n    # Calculate taxes (maintains precision)\n    federal_tax = taxable * rate\n    state_tax = taxable * 0.05  # 5% state tax\n    total_tax = federal_tax + state_tax\n\n    # Net income\n    net_income = gross - total_tax\n\n    return {\n        'gross': gross,\n        'deductions': deduct,\n        'taxable': taxable,\n        'federal_tax': federal_tax,\n        'state_tax': state_tax,\n        'total_tax': total_tax,\n        'net_income': net_income,\n        'effective_rate': (total_tax / gross) * 100\n    }\n\n# Calculate for $75,000 salary\nbreakdown = calculate_tax_breakdown(\"75000.00\", 0.22, \"12550.00\")\n\nprint(\"Tax Breakdown:\")\nprint(f\"Gross Salary: {breakdown['gross']}\")\nprint(f\"Standard Deduction: {breakdown['deductions']}\")\nprint(f\"Taxable Income: {breakdown['taxable']}\")\nprint(f\"Federal Tax (22%): {breakdown['federal_tax']}\")\nprint(f\"State Tax (5%): {breakdown['state_tax']}\")\nprint(f\"Total Tax: {breakdown['total_tax']}\")\nprint(f\"Net Income: {breakdown['net_income']}\")\nprint(f\"Effective Rate: {breakdown['effective_rate']:.2f}%\")\n</code></pre> <p>Output: <pre><code>Tax Breakdown:\nGross Salary: 75,000.00\nStandard Deduction: 12,550.00\nTaxable Income: 62,450.00\nFederal Tax (22%): 13,739.00\nState Tax (5%): 3,122.50\nTotal Tax: 16,861.50\nNet Income: 58,138.50\nEffective Rate: 22.48%\n</code></pre></p>"},{"location":"examples/money/#performance-considerations","title":"Performance Considerations","text":"<p>While <code>Money</code> uses <code>Decimal</code> for precision, it's optimized for financial calculations:</p> <pre><code>import time\nfrom money_warp import Money\n\n# Benchmark Money operations\nstart = time.time()\ntotal = Money.zero()\nfor i in range(10000):\n    total += Money(\"1.23\")\nend = time.time()\n\nprint(f\"10,000 additions: {end - start:.4f} seconds\")\nprint(f\"Final total: {total}\")\n\n# Memory efficiency\nmoney = Money(\"123456789.123456789\")\nprint(f\"Memory efficient: {money}\")  # Only stores one Decimal\n</code></pre>"},{"location":"examples/money/#best-practices","title":"Best Practices","text":"<ol> <li>Use strings for input: <code>Money(\"99.99\")</code> not <code>Money(99.99)</code></li> <li>Leverage precision: Internal calculations maintain full precision</li> <li>Display consistency: All output shows 2 decimals automatically</li> <li>Comparison safety: Comparisons use \"real money\" (2 decimal) values -- works with both <code>Money</code> and <code>Decimal</code></li> <li>Zero handling: Use <code>Money.zero()</code> and <code>.is_zero()</code> for clarity</li> </ol>"},{"location":"examples/money/#common-patterns","title":"Common Patterns","text":"<pre><code># Running totals\ntotal = Money.zero()\ntransactions = [Money(\"100.00\"), Money(\"-25.50\"), Money(\"75.25\")]\nfor transaction in transactions:\n    total += transaction\nprint(f\"Final balance: {total}\")\n\n# Percentage calculations\nprincipal = Money(\"10000.00\")\ninterest_rate = 0.05\ninterest = principal * interest_rate\nprint(f\"Interest: {interest}\")\n\n# Splitting amounts\nbill = Money(\"127.50\")\npeople = 3\nper_person = bill / people\nprint(f\"Per person: {per_person}\")\n\n# Rounding behavior (automatic)\nprecise_calc = Money(\"100.00\") / 3 * 3\nprint(f\"Rounded result: {precise_calc}\")  # Shows 100.00\nprint(f\"Internal: {precise_calc.raw_amount}\")  # Shows full precision\n</code></pre> <p>The <code>Money</code> class ensures your financial calculations are both precise and intuitive! \ud83d\udcb0</p>"},{"location":"examples/present_value_irr/","title":"Present Value and IRR Analysis","text":"<p>MoneyWarp provides comprehensive Time Value of Money (TVM) functions powered by scipy for robust numerical calculations.</p> <p>\ud83d\udca1 Design Philosophy: MoneyWarp focuses on Present Value calculations because with our Time Machine, you can simply \"voyage dans le temps\" to any future date and observe values directly. Future Value functions are unnecessary when you can warp to the future! \ud83d\udd70\ufe0f</p>"},{"location":"examples/present_value_irr/#present-value-functions","title":"Present Value Functions","text":""},{"location":"examples/present_value_irr/#basic-present-value","title":"Basic Present Value","text":"<p>Calculate the present value of any cash flow stream:</p> <pre><code>from money_warp import CashFlow, CashFlowItem, Money, InterestRate, present_value\nfrom datetime import datetime\n\n# Create a cash flow\nitems = [\n    CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n    CashFlowItem(Money(\"300\"), datetime(2024, 6, 1), \"Return 1\", \"return\"),\n    CashFlowItem(Money(\"400\"), datetime(2024, 12, 1), \"Return 2\", \"return\"),\n    CashFlowItem(Money(\"500\"), datetime(2025, 6, 1), \"Return 3\", \"return\"),\n]\ncash_flow = CashFlow(items)\n\n# Calculate present value at 8% annual discount rate\ndiscount_rate = InterestRate(\"8% annual\")\npv = present_value(cash_flow, discount_rate)\nprint(f\"Present Value: {pv}\")\n</code></pre>"},{"location":"examples/present_value_irr/#present-value-of-annuities","title":"Present Value of Annuities","text":"<p>Calculate PV of regular payment streams:</p> <pre><code>from money_warp import present_value_of_annuity\n\n# PV of $1000 monthly payments for 12 months at 5% annual\nmonthly_rate = InterestRate(\"5% annual\").to_monthly()\npv_annuity = present_value_of_annuity(\n    payment_amount=Money(\"1000\"),\n    interest_rate=monthly_rate,\n    periods=12\n)\nprint(f\"PV of Annuity: {pv_annuity}\")\n\n# Annuity due (payments at beginning of period)\npv_due = present_value_of_annuity(\n    payment_amount=Money(\"1000\"),\n    interest_rate=monthly_rate,\n    periods=12,\n    payment_timing=\"begin\"\n)\nprint(f\"PV of Annuity Due: {pv_due}\")\n</code></pre>"},{"location":"examples/present_value_irr/#present-value-of-perpetuities","title":"Present Value of Perpetuities","text":"<p>Calculate PV of infinite payment streams:</p> <pre><code>from money_warp import present_value_of_perpetuity\n\n# PV of $100 annual payments forever at 5%\npv_perpetuity = present_value_of_perpetuity(\n    payment_amount=Money(\"100\"),\n    interest_rate=InterestRate(\"5% annual\")\n)\nprint(f\"PV of Perpetuity: {pv_perpetuity}\")  # Should be $2000\n</code></pre>"},{"location":"examples/present_value_irr/#internal-rate-of-return-irr","title":"Internal Rate of Return (IRR)","text":""},{"location":"examples/present_value_irr/#basic-irr-calculation","title":"Basic IRR Calculation","text":"<p>Find the rate where NPV equals zero:</p> <pre><code>from money_warp import irr\n\n# Simple investment example\nitems = [\n    CashFlowItem(Money(\"-1000\"), datetime(2024, 1, 1), \"Investment\", \"investment\"),\n    CashFlowItem(Money(\"1100\"), datetime(2024, 12, 31), \"Return\", \"return\"),\n]\ncash_flow = CashFlow(items)\n\n# Calculate IRR\ninvestment_irr = irr(cash_flow)\nprint(f\"IRR: {investment_irr}\")  # Should be ~10%\n</code></pre>"},{"location":"examples/present_value_irr/#irr-with-day-count-convention","title":"IRR with Day-Count Convention","text":"<p>By default IRR uses a 365-day (commercial) year. Pass <code>year_size</code> to switch to the 360-day banker's convention:</p> <pre><code>from money_warp import YearSize\n\n# Commercial year (365 days) \u2014 the default\ncommercial_irr = irr(cash_flow, year_size=YearSize.commercial)\nprint(f\"IRR (365-day year): {commercial_irr}\")\n\n# Banker's year (360 days)\nbanker_irr = irr(cash_flow, year_size=YearSize.banker)\nprint(f\"IRR (360-day year): {banker_irr}\")  # Slightly different rate\n</code></pre> <p>The returned <code>InterestRate</code> carries the same <code>year_size</code>, so downstream conversions (e.g. <code>to_daily()</code>) stay consistent.</p>"},{"location":"examples/present_value_irr/#irr-with-custom-initial-guess","title":"IRR with Custom Initial Guess","text":"<p>Provide a starting point for the numerical solver:</p> <pre><code># Use custom initial guess\nguess = InterestRate(\"15% annual\")\nirr_with_guess = irr(cash_flow, guess=guess)\nprint(f\"IRR with guess: {irr_with_guess}\")  # Same result, different path\n</code></pre>"},{"location":"examples/present_value_irr/#complex-cash-flow-irr","title":"Complex Cash Flow IRR","text":"<p>IRR works with irregular cash flows:</p> <pre><code># Complex investment with multiple cash flows\ncomplex_items = [\n    CashFlowItem(Money(\"-10000\"), datetime(2024, 1, 1), \"Initial investment\", \"investment\"),\n    CashFlowItem(Money(\"2000\"), datetime(2024, 3, 1), \"Q1 return\", \"return\"),\n    CashFlowItem(Money(\"-1000\"), datetime(2024, 6, 1), \"Additional investment\", \"investment\"),\n    CashFlowItem(Money(\"3000\"), datetime(2024, 9, 1), \"Q3 return\", \"return\"),\n    CashFlowItem(Money(\"8000\"), datetime(2024, 12, 31), \"Final return\", \"return\"),\n]\ncomplex_cf = CashFlow(complex_items)\n\ncomplex_irr = irr(complex_cf)\nprint(f\"Complex IRR: {complex_irr}\")\n</code></pre>"},{"location":"examples/present_value_irr/#modified-internal-rate-of-return-mirr","title":"Modified Internal Rate of Return (MIRR)","text":"<p>MIRR addresses IRR limitations by using different rates for financing and reinvestment:</p> <pre><code>from money_warp import modified_internal_rate_of_return\n\n# MIRR with different financing and reinvestment rates\nfinance_rate = InterestRate(\"10% annual\")      # Cost of borrowing\nreinvestment_rate = InterestRate(\"6% annual\")  # Reinvestment return\n\nmirr = modified_internal_rate_of_return(\n    cash_flow=complex_cf,\n    finance_rate=finance_rate,\n    reinvestment_rate=reinvestment_rate\n)\nprint(f\"MIRR: {mirr}\")\n\n# MIRR also accepts year_size for day-count convention\nmirr_banker = modified_internal_rate_of_return(\n    cash_flow=complex_cf,\n    finance_rate=finance_rate,\n    reinvestment_rate=reinvestment_rate,\n    year_size=YearSize.banker\n)\nprint(f\"MIRR (360-day year): {mirr_banker}\")\n</code></pre>"},{"location":"examples/present_value_irr/#loan-analysis-sugar-syntax","title":"Loan Analysis Sugar Syntax","text":""},{"location":"examples/present_value_irr/#loan-present-value","title":"Loan Present Value","text":"<p>Calculate loan PV from borrower's perspective:</p> <pre><code>from money_warp import Loan\n\n# Create a loan\nloan = Loan(\n    principal=Money(\"10000\"),\n    interest_rate=InterestRate(\"5% annual\"),\n    due_dates=[datetime(2024, 6, 1), datetime(2024, 12, 1)],\n    disbursement_date=datetime(2024, 1, 1)\n)\n\n# Present value using loan's own rate (should be close to zero)\npv_own_rate = loan.present_value()\nprint(f\"PV at loan's rate: {pv_own_rate}\")\n\n# Present value using different discount rate\npv_market_rate = loan.present_value(InterestRate(\"8% annual\"))\nprint(f\"PV at 8%: {pv_market_rate}\")  # Negative from borrower's perspective\n</code></pre>"},{"location":"examples/present_value_irr/#loan-irr","title":"Loan IRR","text":"<p>Calculate loan's effective rate. The loan automatically passes its own <code>year_size</code> to the IRR calculation, so loans created with <code>YearSize.banker</code> compute IRR using a 360-day year:</p> <pre><code># Loan IRR (should equal the loan's interest rate)\nloan_irr = loan.irr()\nprint(f\"Loan IRR: {loan_irr}\")  # Should be ~5%\n\n# IRR with custom guess\nloan_irr_guess = loan.irr(guess=InterestRate(\"3% annual\"))\nprint(f\"Loan IRR with guess: {loan_irr_guess}\")  # Same result\n\n# Loan with banker's year \u2014 IRR automatically uses 360-day convention\nbanker_loan = Loan(\n    principal=Money(\"10000\"),\n    interest_rate=InterestRate(\"5% annual\", year_size=YearSize.banker),\n    due_dates=[datetime(2024, 6, 1), datetime(2024, 12, 1)],\n    disbursement_date=datetime(2024, 1, 1)\n)\nbanker_loan_irr = banker_loan.irr()\nprint(f\"Banker Loan IRR: {banker_loan_irr}\")  # Uses 360-day year\n</code></pre>"},{"location":"examples/present_value_irr/#time-machine-integration","title":"Time Machine Integration","text":""},{"location":"examples/present_value_irr/#irr-from-specific-dates","title":"IRR from Specific Dates","text":"<p>Use the Time Machine to calculate IRR from any point in time:</p> <pre><code>from money_warp import Warp\n\n# Calculate IRR from different time perspectives\ncurrent_irr = loan.irr()\n\n# IRR as of a specific past date\nwith Warp(loan, datetime(2024, 3, 1)) as past_loan:\n    past_irr = past_loan.irr()\n\nprint(f\"Current IRR: {current_irr}\")\nprint(f\"IRR as of March 1: {past_irr}\")\n</code></pre>"},{"location":"examples/present_value_irr/#present-value-with-time-machine","title":"Present Value with Time Machine","text":"<pre><code># Present value from different time perspectives\ncurrent_pv = loan.present_value(InterestRate(\"8% annual\"))\n\nwith Warp(loan, datetime(2024, 2, 1)) as past_loan:\n    past_pv = past_loan.present_value(InterestRate(\"8% annual\"))\n\nprint(f\"Current PV: {current_pv}\")\nprint(f\"PV as of Feb 1: {past_pv}\")\n</code></pre>"},{"location":"examples/present_value_irr/#key-features","title":"Key Features","text":""},{"location":"examples/present_value_irr/#robust-numerics","title":"Robust Numerics","text":"<ul> <li>Scipy-powered: Uses <code>scipy.optimize.brentq</code> for reliable root finding</li> <li>Automatic bracketing: Finds sign changes in NPV function automatically</li> <li>Fallback methods: Uses <code>fsolve</code> if bracketing fails</li> <li>High precision: Maintains decimal precision throughout</li> <li>Day-count conventions: <code>YearSize.commercial</code> (365) or <code>YearSize.banker</code> (360) for IRR and MIRR</li> </ul>"},{"location":"examples/present_value_irr/#error-handling","title":"Error Handling","text":"<ul> <li>Clear messages: Descriptive error messages for common issues</li> <li>Convergence checking: Validates solutions within reasonable tolerance</li> <li>Edge case handling: Handles empty cash flows, single-sign flows, etc.</li> </ul>"},{"location":"examples/present_value_irr/#integration","title":"Integration","text":"<ul> <li>Time Machine: All functions work seamlessly with <code>Warp</code></li> <li>Sugar syntax: Convenient methods on <code>Loan</code> objects</li> <li>Type safety: Full type annotations and mypy compatibility</li> <li>Consistent API: Similar patterns across all TVM functions</li> </ul>"},{"location":"examples/present_value_irr/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/present_value_irr/#investment-analysis","title":"Investment Analysis","text":"<pre><code># Compare investment alternatives\ninvestments = [\n    (\"Project A\", project_a_cashflow),\n    (\"Project B\", project_b_cashflow),\n    (\"Project C\", project_c_cashflow),\n]\n\nhurdle_rate = InterestRate(\"12% annual\")\n\nfor name, cf in investments:\n    pv = present_value(cf, hurdle_rate)\n    irr_rate = irr(cf)\n    print(f\"{name}: PV={pv}, IRR={irr_rate}\")\n</code></pre>"},{"location":"examples/present_value_irr/#loan-comparison","title":"Loan Comparison","text":"<pre><code># Compare loan offers\nloans = [loan_a, loan_b, loan_c]\nmarket_rate = InterestRate(\"7% annual\")\n\nfor i, loan in enumerate(loans, 1):\n    pv = loan.present_value(market_rate)\n    effective_rate = loan.irr()\n    print(f\"Loan {i}: PV={pv}, Effective Rate={effective_rate}\")\n</code></pre>"},{"location":"examples/present_value_irr/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<pre><code># Test different discount rates\nrates = [\"5% annual\", \"8% annual\", \"10% annual\", \"12% annual\"]\n\nfor rate_str in rates:\n    rate = InterestRate(rate_str)\n    pv = present_value(cash_flow, rate)\n    print(f\"PV at {rate}: {pv}\")\n</code></pre> <p>MoneyWarp's TVM functions provide the foundation for sophisticated financial analysis while maintaining simplicity and reliability through scipy-powered numerics.</p>"},{"location":"examples/quickstart/","title":"Quick Start Guide","text":"<p>Welcome to MoneyWarp! This guide will get you up and running with the core concepts in just a few minutes.</p> <p>\u26a0\ufe0f Development Notice: MoneyWarp is in active development (alpha stage). The core functionality is stable and well-tested, but the API may evolve. Not recommended for production use yet.</p>"},{"location":"examples/quickstart/#installation","title":"Installation","text":"<p>Note: MoneyWarp is not yet published to PyPI. For now, install from source:</p> <pre><code>git clone https://github.com/tomas_correa/money-warp.git\ncd money-warp\npip install -e .\n</code></pre> <p>Or using Poetry (recommended for development):</p> <pre><code>git clone https://github.com/tomas_correa/money-warp.git\ncd money-warp\npoetry install\n</code></pre>"},{"location":"examples/quickstart/#basic-loan-analysis","title":"Basic Loan Analysis","text":"<p>Let's start with a simple loan analysis - the most common use case:</p> <pre><code>from datetime import datetime, timedelta\nfrom money_warp import Money, InterestRate, Loan\n\n# Create a $10,000 personal loan at 8% annual interest\nprincipal = Money(\"10000.00\")\nrate = InterestRate(\"8% a\")  # 8% annually\n\n# Set up monthly payments for 2 years (24 payments)\nstart_date = datetime(2024, 1, 1)\ndue_dates = [start_date + timedelta(days=30*i) for i in range(1, 25)]\n\n# Create the loan\nloan = Loan(principal, rate, due_dates)\n\n# Get the payment schedule\nschedule = loan.get_amortization_schedule()\n\nprint(f\"Monthly payment: {schedule[0].payment_amount}\")\nprint(f\"Total interest over life of loan: {schedule.total_interest}\")\nprint(f\"Total amount to be paid: {schedule.total_payments}\")\n</code></pre> <p>Output: <pre><code>Monthly payment: 452.27\nTotal interest over life of loan: 854.48\nTotal amount to be paid: 10,854.48\n</code></pre></p>"},{"location":"examples/quickstart/#payment-breakdown","title":"Payment Breakdown","text":"<p>Let's examine how each payment is split between interest and principal:</p> <pre><code># Look at the first few payments\nfor i in range(3):\n    payment = schedule[i]\n    print(f\"Payment {payment.payment_number}:\")\n    print(f\"  Total: {payment.payment_amount}\")\n    print(f\"  Interest: {payment.interest_payment}\")\n    print(f\"  Principal: {payment.principal_payment}\")\n    print(f\"  Remaining balance: {payment.ending_balance}\")\n    print()\n</code></pre> <p>Output: <pre><code>Payment 1:\n  Total: 452.27\n  Interest: 66.85\n  Principal: 385.42\n  Remaining balance: 9,614.58\n\nPayment 2:\n  Total: 452.27\n  Interest: 64.28\n  Principal: 387.99\n  Remaining balance: 9,226.59\n\nPayment 3:\n  Total: 452.27\n  Interest: 61.69\n  Principal: 390.58\n  Remaining balance: 8,836.01\n</code></pre></p> <p>Notice how the interest portion decreases and principal portion increases over time!</p>"},{"location":"examples/quickstart/#tracking-actual-payments","title":"Tracking Actual Payments","text":"<p>Now let's track what actually happens when you make payments:</p> <pre><code># Record some actual payments\nloan.record_payment(Money(\"452.27\"), datetime(2024, 2, 1), \"First payment\")\nloan.record_payment(Money(\"500.00\"), datetime(2024, 3, 1), \"Extra payment\")  # Paid extra!\n\nprint(f\"Current balance: {loan.current_balance}\")\nprint(f\"Days since last payment: {loan.days_since_last_payment()}\")\n\n# Compare expected vs actual cash flow\nactual_cf = loan.get_actual_cash_flow()\nactual_payments = actual_cf.query.filter_by(category__in=[\"actual_interest\", \"actual_principal\"])\nprint(f\"Total actual payments so far: {actual_payments.sum()}\")\n</code></pre>"},{"location":"examples/quickstart/#cash-flow-analysis","title":"Cash Flow Analysis","text":"<p>MoneyWarp treats everything as cash flows, making it easy to analyze complex scenarios:</p> <pre><code>from money_warp import CashFlow, CashFlowItem\n\n# Create a cash flow for investment analysis\ncash_flows = [\n    CashFlowItem(Money(\"-10000.00\"), datetime(2024, 1, 1), \"Initial investment\", \"investment\"),\n    CashFlowItem(Money(\"500.00\"), datetime(2024, 4, 1), \"Q1 dividend\", \"dividend\"),\n    CashFlowItem(Money(\"500.00\"), datetime(2024, 7, 1), \"Q2 dividend\", \"dividend\"),\n    CashFlowItem(Money(\"500.00\"), datetime(2024, 10, 1), \"Q3 dividend\", \"dividend\"),\n    CashFlowItem(Money(\"11000.00\"), datetime(2024, 12, 31), \"Sale proceeds\", \"sale\"),\n]\n\nportfolio = CashFlow(cash_flows)\n\nprint(f\"Net cash flow: {portfolio.sum()}\")\nprint(f\"Total dividends: {portfolio.query.filter_by(category='dividend').sum()}\")\nprint(f\"Return on investment: {(portfolio.sum() / Money('10000.00')) * 100:.2f}%\")\n</code></pre> <p>Output: <pre><code>Net cash flow: 2,500.00\nTotal dividends: 1,500.00\nReturn on investment: 25.00%\n</code></pre></p>"},{"location":"examples/quickstart/#high-precision-calculations","title":"High-Precision Calculations","text":"<p>MoneyWarp uses Python's Decimal for precision, avoiding floating-point errors:</p> <pre><code># This would cause precision issues with floats\nmoney1 = Money(\"0.1\")\nmoney2 = Money(\"0.2\") \nresult = money1 + money2\n\nprint(f\"0.1 + 0.2 = {result}\")  # Exactly 0.30, not 0.30000000000000004!\n\n# Complex calculations maintain precision\ncomplex_calc = Money(\"100.00\") * 1.08 / 12 * 365.25\nprint(f\"Complex calculation: {complex_calc}\")\nprint(f\"Internal precision: {complex_calc.raw_amount}\")\nprint(f\"Display precision: {complex_calc.real_amount}\")\n</code></pre>"},{"location":"examples/quickstart/#interest-rate-conversions","title":"Interest Rate Conversions","text":"<p>Work with interest rates safely and explicitly:</p> <pre><code># Create rates with clear formats\nannual = InterestRate(\"6.5% a\")      # 6.5% annually\nmonthly = InterestRate(\"0.5417% m\")  # 0.5417% monthly\n\n# Convert between frequencies\nprint(f\"Annual rate: {annual}\")\nprint(f\"As monthly: {annual.to_monthly()}\")\nprint(f\"As daily: {annual.to_daily()}\")\n\n# Safe decimal access\nprint(f\"As decimal: {annual.as_decimal}\")      # 0.065\nprint(f\"As percentage: {annual.as_percentage}\") # 6.5\n</code></pre>"},{"location":"examples/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've seen the basics, explore the detailed examples:</p> <ul> <li>Money &amp; Precision - Deep dive into high-precision calculations</li> <li>Interest Rates - Master interest rate conversions</li> <li>Cash Flow Analysis - Advanced cash flow modeling</li> <li>Time Machine (Warp) - Time travel for financial modeling</li> <li>Present Value &amp; IRR - Investment analysis tools</li> </ul>"},{"location":"examples/quickstart/#key-concepts-recap","title":"Key Concepts Recap","text":"<ol> <li>Money: High-precision monetary amounts with 2-decimal display</li> <li>InterestRate: Type-safe rates with explicit frequency conversion</li> <li>CashFlow: Collections of transactions with powerful querying</li> <li>Loan: State machine for loan analysis with actual vs expected tracking</li> <li>Schedulers: Pluggable algorithms for different amortization methods</li> </ol> <p>Ready to dive deeper? Choose your next topic from the examples above! \ud83d\ude80</p>"},{"location":"examples/tax/","title":"Tax &amp; IOF (Brazilian Financial Operations Tax)","text":"<p>MoneyWarp includes a pluggable tax system built around the <code>BaseTax</code> interface. The first concrete implementation is IOF (Imposto sobre Opera\u00e7\u00f5es Financeiras), the Brazilian tax levied on loan operations. The module also provides a grossup solver for financed taxes \u2014 where the tax is incorporated into the principal so the borrower receives an exact \"requested amount.\"</p>"},{"location":"examples/tax/#iof-basics","title":"IOF Basics","text":"<p>IOF has two components applied to each installment's principal payment:</p> <ul> <li>Daily rate: applied per day from disbursement to payment date (capped at 365 days)</li> <li>Additional rate: a flat percentage applied once per installment</li> </ul> <pre><code>from datetime import datetime\nfrom decimal import Decimal\nfrom money_warp import IOF, Money, InterestRate, PriceScheduler\n\n# Create an IOF with explicit rates\niof = IOF(daily_rate=Decimal(\"0.000082\"), additional_rate=Decimal(\"0.0038\"))\n\n# Rates can also be passed as percentage strings\niof = IOF(daily_rate=\"0.0082%\", additional_rate=\"0.38%\")\n\n# Generate a schedule and calculate IOF\ndisbursement = datetime(2024, 1, 1)\ndue_dates = [datetime(2024, 2, 1), datetime(2024, 3, 1), datetime(2024, 4, 1)]\nschedule = PriceScheduler.generate_schedule(\n    Money(\"10000\"), InterestRate(\"2% m\"), due_dates, disbursement\n)\n\nresult = iof.calculate(schedule, disbursement)\nprint(f\"Total IOF: {result.total}\")\nprint(f\"Installments: {len(result.per_installment)}\")\n\n# Inspect per-installment breakdown\nfor detail in result.per_installment:\n    print(f\"  Period {detail.payment_number}: \"\n          f\"principal={detail.principal_payment}, \"\n          f\"IOF={detail.tax_amount}\")\n</code></pre>"},{"location":"examples/tax/#preset-classes-individualiof-and-corporateiof","title":"Preset Classes: IndividualIOF and CorporateIOF","text":"<p>Brazilian IOF rates differ by borrower type. MoneyWarp provides two preset subclasses with standard rates:</p> Preset Borrower Type Daily Rate Additional Rate <code>IndividualIOF</code> Pessoa Fisica (PF) 0.0082% 0.38% <code>CorporateIOF</code> Pessoa Juridica (PJ) 0.0041% 0.38% <pre><code>from money_warp import IndividualIOF, CorporateIOF\n\n# Zero-config \u2014 just use the standard rates\niof_pf = IndividualIOF()\niof_pj = CorporateIOF()\n\n# Override any parameter if rates change\niof_custom = IndividualIOF(daily_rate=Decimal(\"0.0001\"))\n</code></pre> <p>Both are subclasses of <code>IOF</code> and inherit all behavior. They work anywhere <code>IOF</code> or <code>BaseTax</code> is expected.</p>"},{"location":"examples/tax/#rounding-modes","title":"Rounding Modes","text":"<p>Different systems round IOF components differently. MoneyWarp supports two strategies via <code>IOFRounding</code>:</p> <ul> <li><code>PRECISE</code> (default): sums daily and additional components, then rounds the installment to 2 decimal places</li> <li><code>PER_COMPONENT</code>: rounds each component to 2 decimal places individually before summing \u2014 matches common Brazilian lending platforms</li> </ul> <p>Both modes produce proper 2-decimal money values for every installment.</p> <pre><code>from money_warp import IOF, IOFRounding\n\n# Default: precise rounding\niof_precise = IOF(daily_rate=\"0.0082%\", additional_rate=\"0.38%\")\n\n# Match external system rounding\niof_external = IOF(\n    daily_rate=\"0.0082%\",\n    additional_rate=\"0.38%\",\n    rounding=IOFRounding.PER_COMPONENT,\n)\n\n# Also works with presets\niof_pf = IndividualIOF(rounding=IOFRounding.PER_COMPONENT)\n</code></pre> <p>The difference between modes is at most 1 cent per installment. Use <code>PER_COMPONENT</code> when you need exact reconciliation with an external system.</p>"},{"location":"examples/tax/#loan-with-tax","title":"Loan with Tax","text":"<p>Attach taxes to a <code>Loan</code> for reporting. The loan lazily computes and caches tax amounts from the original schedule:</p> <pre><code>from money_warp import Loan, Money, InterestRate, IndividualIOF, generate_monthly_dates\n\niof = IndividualIOF()\ndue_dates = generate_monthly_dates(datetime(2024, 2, 1), 12)\n\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"1% m\"),\n    due_dates,\n    disbursement_date=datetime(2024, 1, 1),\n    taxes=[iof],\n)\n\n# Tax reporting properties\nprint(f\"Total IOF: {loan.total_tax}\")\nprint(f\"Net disbursement: {loan.net_disbursement}\")  # principal - total_tax\n\n# Per-tax breakdown (keyed by class name)\nfor name, result in loan.tax_amounts.items():\n    print(f\"{name}: {result.total}\")\n</code></pre> <p>When taxes are present, <code>generate_expected_cash_flow()</code> includes an <code>\"expected_tax\"</code> item at the disbursement date, so IRR and present value calculations automatically account for the tax.</p>"},{"location":"examples/tax/#grossup-financed-tax","title":"Grossup: Financed Tax","text":"<p>When the tax is financed (incorporated into the principal), the borrower receives at least the \"requested amount\" after tax deduction. The <code>grossup()</code> function uses <code>scipy.optimize.brentq</code> (bracketed bisection) to find the principal where <code>principal - tax(principal) &gt;= requested_amount</code>, then snaps the result to a clean cent-aligned principal. In most cases the net equals the requested amount exactly; in rare rounding-boundary cases the borrower receives up to 1 cent more (never less).</p> <pre><code>from money_warp import grossup, Money, InterestRate, PriceScheduler, IndividualIOF\n\niof = IndividualIOF()\ndue_dates = generate_monthly_dates(datetime(2024, 2, 1), 12)\n\nresult = grossup(\n    requested_amount=Money(\"10000\"),\n    interest_rate=InterestRate(\"1% m\"),\n    due_dates=due_dates,\n    disbursement_date=datetime(2024, 1, 1),\n    scheduler=PriceScheduler,\n    taxes=[iof],\n)\n\nprint(f\"Grossed-up principal: {result.principal}\")     # &gt; 10,000\nprint(f\"Requested amount: {result.requested_amount}\")  # 10,000\nprint(f\"Total tax: {result.total_tax}\")\n\n# Create a Loan from the result\nloan = result.to_loan()\nprint(f\"Net disbursement: {loan.net_disbursement}\")  # ~= 10,000\n</code></pre>"},{"location":"examples/tax/#grossup_loan-the-common-case","title":"<code>grossup_loan()</code> \u2014 The Common Case","text":"<p>Most of the time you want the grossed-up <code>Loan</code> directly. The <code>grossup_loan()</code> function does <code>grossup(...).to_loan(...)</code> in a single call:</p> <pre><code>from money_warp import grossup_loan, Money, InterestRate, PriceScheduler, IndividualIOF\nfrom decimal import Decimal\n\niof = IndividualIOF()\ndue_dates = generate_monthly_dates(datetime(2024, 2, 1), 12)\n\nloan = grossup_loan(\n    requested_amount=Money(\"10000\"),\n    interest_rate=InterestRate(\"1% m\"),\n    due_dates=due_dates,\n    disbursement_date=datetime(2024, 1, 1),\n    scheduler=PriceScheduler,\n    taxes=[iof],\n    fine_rate=Decimal(\"0.05\"),   # forwarded to Loan\n    grace_period_days=3,         # forwarded to Loan\n)\n\nprint(f\"Principal: {loan.principal}\")              # &gt; 10,000\nprint(f\"Net to borrower: {loan.net_disbursement}\") # ~= 10,000\nprint(f\"Total IOF: {loan.total_tax}\")\n</code></pre>"},{"location":"examples/tax/#custom-taxes","title":"Custom Taxes","text":"<p>To add support for a different tax, subclass <code>BaseTax</code> and implement <code>calculate()</code>:</p> <pre><code>from money_warp.tax.base import BaseTax, TaxResult, TaxInstallmentDetail\n\nclass MyTax(BaseTax):\n    def calculate(self, schedule, disbursement_date):\n        details = []\n        total = Money.zero()\n        for entry in schedule:\n            tax_amount = entry.principal_payment * Decimal(\"0.01\")  # 1% flat\n            details.append(TaxInstallmentDetail(\n                payment_number=entry.payment_number,\n                due_date=entry.due_date,\n                principal_payment=entry.principal_payment,\n                tax_amount=tax_amount,\n            ))\n            total = total + tax_amount\n        return TaxResult(total=total, per_installment=details)\n</code></pre> <p>Custom taxes work with <code>Loan(taxes=[...])</code>, <code>grossup()</code>, and <code>grossup_loan()</code> \u2014 the entire system is polymorphic over <code>BaseTax</code>.</p>"},{"location":"examples/tax/#key-properties","title":"Key Properties","text":"Property / Function Type Description <code>loan.total_tax</code> <code>Money</code> Sum of all taxes on the loan <code>loan.net_disbursement</code> <code>Money</code> <code>principal - total_tax</code> <code>loan.tax_amounts</code> <code>Dict[str, TaxResult]</code> Per-tax results keyed by class name <code>grossup()</code> <code>GrossupResult</code> Finds the grossed-up principal <code>grossup_loan()</code> <code>Loan</code> Sugar: grossup + create loan in one call <code>IOFRounding.PRECISE</code> enum Sum-then-round (default) <code>IOFRounding.PER_COMPONENT</code> enum Round-then-sum (matches external systems)"},{"location":"examples/tax/#cash-flow-categories","title":"Cash Flow Categories","text":"<p>When taxes are attached to a loan, the expected cash flow includes:</p> Category Meaning <code>\"expected_tax\"</code> Tax deducted at disbursement (negative from borrower's perspective)"},{"location":"examples/time_machine/","title":"Time Machine (Warp) Examples","text":"<p>Core Philosophy: The loan is always time sensitive... it always filters based on present date regardless if it is warped or not... the warp just changes the present date.</p>"},{"location":"examples/time_machine/#basic-time-travel","title":"Basic Time Travel","text":"<pre><code>from money_warp import Warp, Loan, Money, InterestRate\nfrom datetime import datetime\n\n# Create a loan\nloan = Loan(\n    Money(\"10000\"), \n    InterestRate(\"5% annual\"), \n    [datetime(2024, 1, 15), datetime(2024, 2, 15), datetime(2024, 3, 15)]\n)\n\n# Make some payments\nloan.record_payment(Money(\"500\"), datetime(2024, 1, 10), \"Payment 1\")\nloan.record_payment(Money(\"600\"), datetime(2024, 2, 10), \"Payment 2\") \nloan.record_payment(Money(\"700\"), datetime(2024, 3, 10), \"Payment 3\")\n\nprint(f\"Current balance: {loan.current_balance}\")\n# Current balance: 8,200.00 (approximately, after all payments)\n</code></pre>"},{"location":"examples/time_machine/#warp-to-the-past","title":"Warp to the Past","text":"<pre><code># Travel back to January 20th - only first payment has been made\nwith Warp(loan, datetime(2024, 1, 20)) as past_loan:\n    print(f\"Balance on Jan 20: {past_loan.current_balance}\")\n    # Balance on Jan 20: 9,500.00 (approximately, only first payment applied)\n\n    print(f\"Payments made by Jan 20: {len(past_loan._actual_payments)}\")\n    # Payments made by Jan 20: 2 (interest + principal portions of first payment)\n\n    # Time-dependent calculations use the warped date\n    days_since = past_loan.days_since_last_payment()\n    print(f\"Days since last payment (from Jan 20): {days_since}\")\n    # Days since last payment (from Jan 20): 10 (Jan 20 - Jan 10)\n\n# Original loan is unchanged\nprint(f\"Back to present: {loan.current_balance}\")\n# Back to present: 8,200.00 (all payments still applied)\n</code></pre>"},{"location":"examples/time_machine/#warp-to-the-future","title":"Warp to the Future","text":"<pre><code># Travel to the future - all payments are still visible\nwith Warp(loan, datetime(2025, 6, 15)) as future_loan:\n    print(f\"Balance in June 2025: {future_loan.current_balance}\")\n    # Balance in June 2025: 8,200.00 (same as present, no new payments)\n\n    print(f\"All payments made: {len(future_loan._actual_payments)}\")\n    # All payments made: 6 (all 3 payments \u00d7 2 components each)\n\n    # Time calculations from the future perspective\n    days_since = future_loan.days_since_last_payment()\n    print(f\"Days since last payment (from June 2025): {days_since}\")\n    # Days since last payment (from June 2025): ~460 days\n</code></pre>"},{"location":"examples/time_machine/#flexible-date-formats","title":"Flexible Date Formats","text":"<pre><code># String dates (ISO format)\nwith Warp(loan, \"2024-01-20\") as warped:\n    print(f\"String date: {warped.current_balance}\")\n\n# datetime objects\nwith Warp(loan, datetime(2024, 1, 20, 14, 30)) as warped:\n    print(f\"Datetime object: {warped.current_balance}\")\n\n# date objects\nfrom datetime import date\nwith Warp(loan, date(2024, 1, 20)) as warped:\n    print(f\"Date object: {warped.current_balance}\")\n</code></pre>"},{"location":"examples/time_machine/#safety-features","title":"Safety Features","text":"<pre><code># Nested warps are prevented\nwith Warp(loan, \"2024-01-20\") as outer_warp:\n    try:\n        with Warp(loan, \"2024-02-20\") as inner_warp:  # This will fail\n            pass\n    except NestedWarpError as e:\n        print(f\"Nested warp prevented: {e}\")\n        # Nested warp prevented: Nested Warp contexts are not allowed. \n        # Playing with time is dangerous enough with one level.\n\n# Invalid dates are caught\ntry:\n    with Warp(loan, \"not-a-date\") as warped:\n        pass\nexcept InvalidDateError as e:\n    print(f\"Invalid date caught: {e}\")\n    # Invalid date caught: Could not parse date 'not-a-date': ...\n</code></pre>"},{"location":"examples/time_machine/#real-world-scenario-payment-analysis","title":"Real-World Scenario: Payment Analysis","text":"<pre><code># Analyze loan performance at different points in time\nloan = Loan(Money(\"50000\"), InterestRate(\"4.5% annual\"), \n           [datetime(2024, i, 1) for i in range(1, 13)])  # Monthly payments\n\n# Record some irregular payments\nloan.record_payment(Money(\"4500\"), datetime(2024, 1, 1), \"On time\")\nloan.record_payment(Money(\"4500\"), datetime(2024, 2, 5), \"5 days late\") \nloan.record_payment(Money(\"2000\"), datetime(2024, 3, 1), \"Partial payment\")\nloan.record_payment(Money(\"2500\"), datetime(2024, 3, 15), \"Catch up payment\")\n\n# Analyze at different points\nanalysis_dates = [\n    datetime(2024, 1, 31),  # After first payment\n    datetime(2024, 2, 28),  # After second payment  \n    datetime(2024, 3, 31),  # After all March payments\n]\n\nfor analysis_date in analysis_dates:\n    with Warp(loan, analysis_date) as snapshot:\n        print(f\"\\n=== Analysis as of {analysis_date.strftime('%B %Y')} ===\")\n        print(f\"Outstanding balance: {snapshot.current_balance}\")\n        print(f\"Payments made: {len(snapshot._actual_payments) // 2}\")  # Divide by 2 for payment count\n        print(f\"Days since last payment: {snapshot.days_since_last_payment()}\")\n</code></pre>"},{"location":"examples/time_machine/#key-benefits","title":"Key Benefits","text":"<ol> <li>Natural Time Filtering: Loans automatically show the correct state for any date</li> <li>Safe Analysis: Original loan data is never modified during time travel</li> <li>Instant Calculations: All loan properties update automatically based on the warped time</li> <li>Flexible Integration: Works seamlessly with existing loan methods and properties</li> <li>Error Prevention: Built-in safeguards against nested warps and invalid dates</li> </ol> <p>The Time Machine makes it trivial to analyze loan performance at any point in history or project future states based on current payment patterns.</p>"},{"location":"examples/timezone/","title":"Timezone Handling \ud83c\udf10","text":"<p>MoneyWarp uses timezone-aware datetimes throughout the library. By default, all datetimes are treated as UTC. You can change this default globally, and naive datetimes passed to any API are silently coerced to the configured timezone.</p>"},{"location":"examples/timezone/#why-timezone-aware","title":"Why Timezone-Aware?","text":"<p>Mixing naive and aware datetimes in Python raises <code>TypeError</code> on comparison. By enforcing awareness everywhere, MoneyWarp avoids this class of bugs entirely. Financial calculations \u2014 especially across jurisdictions \u2014 benefit from unambiguous timestamps.</p>"},{"location":"examples/timezone/#default-timezone","title":"Default Timezone","text":"<pre><code>from money_warp import get_tz, now\n\n# The default is UTC\nprint(get_tz())  # datetime.timezone.utc\n\n# now() always returns a timezone-aware datetime\ncurrent = now()\nprint(current)  # e.g. 2024-06-15 14:30:00+00:00\n</code></pre>"},{"location":"examples/timezone/#changing-the-default","title":"Changing the Default","text":"<p>Use <code>set_tz()</code> with an IANA timezone name or a <code>tzinfo</code> object:</p> <pre><code>from money_warp import set_tz, get_tz, now\n\n# IANA timezone name (uses zoneinfo.ZoneInfo internally)\nset_tz(\"America/Sao_Paulo\")\nprint(get_tz())  # zoneinfo.ZoneInfo(key='America/Sao_Paulo')\nprint(now())     # e.g. 2024-06-15 11:30:00-03:00\n\n# Fixed UTC offset\nfrom datetime import timezone, timedelta\nset_tz(timezone(timedelta(hours=5, minutes=30)))\nprint(now())     # e.g. 2024-06-15 20:00:00+05:30\n\n# Reset to UTC\nset_tz(\"UTC\")\n</code></pre>"},{"location":"examples/timezone/#naive-datetime-coercion","title":"Naive Datetime Coercion","text":"<p>Naive datetimes (without <code>tzinfo</code>) are accepted everywhere. The library attaches the current default timezone automatically:</p> <pre><code>from datetime import datetime\nfrom money_warp import ensure_aware, set_tz\n\n# With default UTC\ndt = ensure_aware(datetime(2024, 6, 15))\nprint(dt)  # 2024-06-15 00:00:00+00:00\n\n# Already-aware datetimes pass through unchanged\nfrom datetime import timezone\naware_dt = datetime(2024, 6, 15, tzinfo=timezone.utc)\nprint(ensure_aware(aware_dt))  # 2024-06-15 00:00:00+00:00 (unchanged)\n\n# With a different default timezone\nset_tz(\"America/New_York\")\ndt = ensure_aware(datetime(2024, 6, 15))\nprint(dt)  # 2024-06-15 00:00:00-04:00\n\nset_tz(\"UTC\")  # reset\n</code></pre>"},{"location":"examples/timezone/#using-with-loans-and-cash-flows","title":"Using with Loans and Cash Flows","text":"<p>You don't need to explicitly call <code>ensure_aware()</code> \u2014 all public APIs handle it automatically. Naive datetimes work as input for convenience:</p> <pre><code>from datetime import datetime\nfrom money_warp import Loan, Money, InterestRate, generate_monthly_dates\n\n# Naive datetimes are silently coerced to UTC\nloan = Loan(\n    Money(\"10000\"),\n    InterestRate(\"5% a\"),\n    generate_monthly_dates(datetime(2024, 2, 1), 12),\n    disbursement_date=datetime(2024, 1, 1),\n)\n\n# All stored datetimes are now timezone-aware\nprint(loan.disbursement_date)  # 2024-01-01 00:00:00+00:00\nprint(loan.due_dates[0])       # 2024-02-01 00:00:00+00:00\n</code></pre> <p>The same applies to <code>CashFlowItem</code>, <code>Warp</code>, <code>record_payment</code>, and all other datetime-accepting APIs.</p>"},{"location":"examples/timezone/#the-tz_aware-decorator","title":"The <code>@tz_aware</code> Decorator","text":"<p>Under the hood, MoneyWarp uses a <code>@tz_aware</code> decorator on public API methods. This decorator inspects function arguments and converts any <code>datetime</code> (or <code>list[datetime]</code>) to timezone-aware before the function body runs.</p> <p>You can use it in your own code if you integrate with MoneyWarp:</p> <pre><code>from datetime import datetime\nfrom money_warp import tz_aware\n\n@tz_aware\ndef process_payment(amount: float, payment_date: datetime) -&gt; str:\n    # payment_date is guaranteed to be timezone-aware here\n    return f\"Processed {amount} at {payment_date}\"\n\n# Naive datetime is coerced automatically\nresult = process_payment(100.0, datetime(2024, 6, 15))\nprint(result)  # Processed 100.0 at 2024-06-15 00:00:00+00:00\n</code></pre>"},{"location":"examples/timezone/#testing-tips","title":"Testing Tips","text":"<p>When writing tests against MoneyWarp, you can either:</p> <ol> <li>Use naive datetimes \u2014 they are coerced automatically, so your test setup stays clean</li> <li>Use explicit <code>tzinfo=timezone.utc</code> \u2014 for clarity and to match the stored values exactly</li> </ol> <pre><code>from datetime import datetime, timezone\n\n# Both approaches work for input\nloan = Loan(Money(\"1000\"), InterestRate(\"5% a\"), [datetime(2024, 2, 1)])\nloan = Loan(Money(\"1000\"), InterestRate(\"5% a\"), [datetime(2024, 2, 1, tzinfo=timezone.utc)])\n\n# For assertions, use aware datetimes to match stored values\nassert loan.due_dates[0] == datetime(2024, 2, 1, tzinfo=timezone.utc)\n</code></pre>"},{"location":"examples/timezone/#public-api","title":"Public API","text":"Function Description <code>get_tz()</code> Returns the current default <code>tzinfo</code> <code>set_tz(tz)</code> Sets the default timezone (string or <code>tzinfo</code>) <code>now()</code> Returns <code>datetime.now()</code> in the configured timezone <code>ensure_aware(dt)</code> Coerces a naive datetime; passes aware datetimes through <code>tz_aware</code> Decorator that coerces <code>datetime</code> arguments automatically"}]}